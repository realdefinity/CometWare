-- Load Rayfield Library
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Create the Rayfield UI Window
local Window = Rayfield:CreateWindow({
    Name = "COMET: shrimp game edition",
    LoadingTitle = "Loading Shrimp Game...",
    LoadingSubtitle = "By Definity",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "Comet shrimp game", -- Save configs in a folder
        FileName = "ShrimpDominator" -- Config file name
    },
    Discord = {
        Enabled = true,
        Invite = "https://discord.gg/qeFQ57eqtj", -- Replace with your Discord invite if needed
        RememberJoins = true
    }
})

-- ðŸŒŸ Tabs for Features
local MainTab = Window:CreateTab("Main Features", 4483362458) -- Main gameplay features
local VisualsTab = Window:CreateTab("Visuals", 4483362458) -- ESP & visuals
local MovementTab = Window:CreateTab("Movement", 4483362458) -- Speed, jump boosts
local MiscTab = Window:CreateTab("Miscellaneous", 4483362458) -- Other fun stuff

-- ðŸŒŸ Global Variables (Toggle States)
local toggles = {
    espEnabled = false,
    autoWin = false,
    infiniteJump = false,
    speedBoost = false,
    jumpBoost = false
}

-- ðŸŒŸ Function to Notify Players
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- ðŸŒŸ MainTab: Auto Win Toggle
MainTab:CreateToggle({
    Name = "Enable Auto Win",
    CurrentValue = false,
    Flag = "AutoWinToggle",
    Callback = function(Value)
        toggles.autoWin = Value
        notify("Auto Win", "Auto Win has been " .. (Value and "enabled" or "disabled") .. ".")
    end
})


-- ðŸŒŸ MiscTab: Reset All Toggles
MiscTab:CreateButton({
    Name = "Reset All Features",
    Callback = function()
        -- Reset all toggles and states
        for key, _ in pairs(toggles) do
            toggles[key] = false
        end
        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16
        game.Players.LocalPlayer.Character.Humanoid.JumpPower = 50
        notify("Reset Features", "All features have been reset.")
    end
})

-- FPS Booster and Setter with Rayfield UI Integration

-- ðŸŒŸ FPS Booster Variables
local FPSBooster = {}
local toggles = {
    fpsBoostEnabled = false
}
local defaultWalkSpeed = 16 -- Default Roblox walk speed (used in resets)

-- ðŸŒŸ Function to Notify Players
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- ðŸŒŸ FPS Booster Logic
function FPSBooster:Boost()
    -- Optimize Workspace
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") then
            obj.Material = Enum.Material.SmoothPlastic -- Simplify materials
            obj.Reflectance = 0 -- Remove reflections
        elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
            obj.Enabled = false -- Disable particles and trails
        elseif obj:IsA("Beam") then
            obj.Enabled = false -- Disable beams
        elseif obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then
            obj.Enabled = false -- Disable unnecessary lights
        end
    end

    -- Optimize Lighting
    local Lighting = game:GetService("Lighting")
    Lighting.GlobalShadows = false -- Disable global shadows
    Lighting.FogEnd = 9e9 -- Remove fog
    Lighting.Brightness = 1 -- Simplify brightness
    Lighting.EnvironmentSpecularScale = 0 -- Disable specular effects
    Lighting.EnvironmentDiffuseScale = 0 -- Disable diffuse lighting

    -- Disable Terrain Decoration
    if workspace:FindFirstChildOfClass("Terrain") then
        workspace.Terrain.Decoration = false
    end

    -- Notify Player
    notify("FPS Booster", "FPS Booster applied! Performance optimized.")
end

-- ðŸŒŸ FPS Setter Logic
function FPSBooster:SetFPSCap(fps)
    if setfpscap then
        setfpscap(fps)
        notify("FPS Cap", "FPS cap set to " .. tostring(fps) .. " FPS.")
    else
        notify("Error", "Your executor does not support `setfpscap`.")
    end
end

-- ðŸŒŸ UI Integration
VisualsTab:CreateButton({
    Name = "Apply FPS Boost",
    Callback = function()
        FPSBooster:Boost()
    end
})

-- FPS Cap Slider
VisualsTab:CreateSlider({
    Name = "Set FPS Cap",
    Range = {30, 300}, -- Min/Max FPS values
    Increment = 10, -- Adjust in steps of 10
    CurrentValue = 60, -- Default FPS cap
    Flag = "FPSCapSlider",
    Callback = function(Value)
        FPSBooster:SetFPSCap(Value)
    end
})

-- Red Light Green Light Feature
local RedLightGreenLight = {}
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Variables
local reactionTime = 0 -- Reaction time in seconds
local defaultWalkSpeed = 16 -- Default walk speed
local isGreenLight = true -- Current light state
local lightDetectionMethod = "signal" -- Options: "signal" or "timer"

-- Helper: Notify Function
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- Helper: Change Movement State
local function changeMovementState(canMove)
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("Humanoid") then return end

    local humanoid = character:FindFirstChild("Humanoid")
    if canMove then
        humanoid.WalkSpeed = defaultWalkSpeed
    else
        humanoid.WalkSpeed = 0 -- Stop movement
    end
end

-- Light Detection Logic
function RedLightGreenLight:DetectLights()
    if lightDetectionMethod == "signal" then
        -- Example detection (replace with actual game logic if applicable)
        local lightText = game:GetService("Workspace"):FindFirstChild("LightIndicator") -- Example object
        if lightText and lightText:IsA("TextLabel") then
            isGreenLight = lightText.Text == "Green Light"
        end
    elseif lightDetectionMethod == "timer" then
        -- Fallback to timed simulation if no light signals are available
        task.spawn(function()
            while true do
                isGreenLight = not isGreenLight -- Toggle light state
                notify("Light State", "The light is now " .. (isGreenLight and "Green!" or "Red!"))
                task.wait(math.random(3, 6)) -- Random green/red durations
            end
        end)
    end
end

-- Movement Control Logic
function RedLightGreenLight:ControlMovement()
    RunService.Heartbeat:Connect(function()
        local character = LocalPlayer.Character
        if not character or not character:FindFirstChild("Humanoid") then return end

        -- Reaction delay
        task.wait(reactionTime)

        -- Control movement based on light state
        if isGreenLight then
            changeMovementState(true) -- Allow movement
        else
            changeMovementState(false) -- Stop movement
        end
    end)
end

-- Initialize Feature
function RedLightGreenLight:Start()
    notify("Red Light Green Light", "Auto Play enabled!")
    self:DetectLights() -- Start light detection
    self:ControlMovement() -- Control player movement
end

-- UI Integration
local MainTab = Window:CreateTab("Red Light Green Light", 4483362458)

-- Enable Auto Play
MainTab:CreateButton({
    Name = "Start Red Light Green Light",
    Callback = function()
        RedLightGreenLight:Start()
    end
})

-- Reaction Time Slider
MainTab:CreateSlider({
    Name = "Reaction Time",
    Range = {0, 1}, -- 0 for instant reaction, up to 1 second
    Increment = 0.1,
    CurrentValue = 0,
    Flag = "ReactionTimeSlider",
    Callback = function(Value)
        reactionTime = Value
        notify("Reaction Time", "Reaction time set to " .. Value .. " seconds.")
    end
})


-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Variables
local toggles = {
    customSpeedEnabled = false
}
local customSpeed = 16 -- Default speed

-- Helper: Notify Function
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- Anti-Cheat Friendly Custom Speed (CFrame Stepping)
local function applyCustomSpeed()
    if toggles.customSpeedEnabled then
        notify("Custom Speed", "Custom Speed enabled! Moving safely...")
    else
        notify("Custom Speed", "Custom Speed disabled.")
        return
    end

    -- Start applying speed
    RunService.Stepped:Connect(function(_, deltaTime)
        if toggles.customSpeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            local rootPart = LocalPlayer.Character.HumanoidRootPart

            -- Prevent anti-cheat from detecting abnormal movement
            if humanoid and humanoid.MoveDirection.Magnitude > 0 then
                -- Apply small, incremental CFrame changes based on movement direction
                local moveDirection = humanoid.MoveDirection * (customSpeed * deltaTime)
                rootPart.CFrame = rootPart.CFrame + Vector3.new(moveDirection.X, 0, moveDirection.Z)
            end
        end
    end)
end

-- Toggle Custom Speed
MovementTab:CreateToggle({
    Name = "Enable Custom Speed",
    CurrentValue = false,
    Flag = "CustomSpeedToggle",
    Callback = function(Value)
        toggles.customSpeedEnabled = Value
        if Value then
            applyCustomSpeed()
        end
    end
})

-- Speed Slider
MovementTab:CreateSlider({
    Name = "Set Custom Speed",
    Range = {16, 50}, -- Safe speed range
    Increment = 2,
    CurrentValue = 16,
    Flag = "CustomSpeedSlider",
    Callback = function(Value)
        customSpeed = Value
        notify("Custom Speed", "Custom Speed set to " .. Value .. ".")
    end
})

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Variables
local toggles = {
    customJumpEnabled = false
}
local jumpPower = 50 -- Default custom jump height

-- Helper: Notify Function
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- Advanced Anti-Cheat Friendly Jump Logic
local function applyCustomJump()
    UserInputService.JumpRequest:Connect(function()
        if toggles.customJumpEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = LocalPlayer.Character.HumanoidRootPart
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if not humanoid or humanoid.FloorMaterial == Enum.Material.Air then return end -- Ensure we're on the ground

            -- Simulate smooth jump with incremental CFrame adjustments
            for i = 1, jumpPower, 5 do
                task.wait(0.01) -- Small delay for smoothness
                rootPart.CFrame = rootPart.CFrame + Vector3.new(0, 0.5, 0) -- Incrementally move up
            end

            -- Simulate landing
            task.wait(0.1)
            rootPart.CFrame = rootPart.CFrame + Vector3.new(0, -0.5, 0) -- Minor correction to mimic landing
        end
    end)
end

-- Toggle Custom Jump Power
MovementTab:CreateToggle({
    Name = "Enable Custom Jump Power",
    CurrentValue = false,
    Flag = "CustomJumpToggle",
    Callback = function(Value)
        toggles.customJumpEnabled = Value
        if Value then
            applyCustomJump()
            notify("Custom Jump Power", "Custom Jump Power enabled!")
        else
            notify("Custom Jump Power", "Custom Jump Power disabled.")
        end
    end
})

-- Jump Power Slider
MovementTab:CreateSlider({
    Name = "Set Custom Jump Power",
    Range = {10, 100}, -- Safe range for jump height
    Increment = 5,
    CurrentValue = 50,
    Flag = "CustomJumpSlider",
    Callback = function(Value)
        jumpPower = Value
        notify("Custom Jump Power", "Jump Power set to " .. Value .. ".")
    end
})

-- Services
local TeleportService = game:GetService("TeleportService")

-- Unique Flag for Singleton Execution
local teleportScriptFlag = "_ScriptQueued"

-- Ensure the script is queued only once
if not getgenv()[teleportScriptFlag] then
    -- Set the global flag to true
    getgenv()[teleportScriptFlag] = true

    -- Script to Execute After Teleport (Replace the URL with your script)
    local scriptToExecute = [[
        loadstring(game:HttpGet("https://raw.githubusercontent.com/realdefinity/comet/refs/heads/main/Shrimp%20Game"))()
    ]]

    -- Queue the script for teleport
    if queue_on_teleport then
        queue_on_teleport(scriptToExecute)
        print("[Queue-on-Teleport] Script successfully queued for teleport.")
    elseif TeleportService.Teleport then
        -- Basic fallback if `queue_on_teleport` isn't available
        warn("[Queue-on-Teleport] Your executor does not support queue_on_teleport, but teleport fallback applied.")
    else
        warn("[Queue-on-Teleport] Your executor does not support teleport queuing.")
    end

    -- Execute the script for the current session
    loadstring(game:HttpGet("https://raw.githubusercontent.com/realdefinity/comet/refs/heads/main/Shrimp%20Game"))()
else
    print("[Queue-on-Teleport] Script is already queued. Avoiding duplicate execution.")
end

-- Auto Cookie Cutter Feature
local CookieCutter = {}
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- Variables
local cuttingEnabled = false
local cuttingSpeed = 0.02 -- Adjust this for smoother or faster cuts

-- Helper: Notify Function
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- Helper: Move Mouse to a Position
local function moveMouseTo(position)
    mousemoveabs(position.X, position.Y)
end

-- Helper: Simulate Mouse Press
local function clickMouse()
    mouse1press()
    task.wait(0.1)
    mouse1release()
end

-- Function to Cut Cookie Shape
function CookieCutter:CutCookie(cookieShape)
    if not cuttingEnabled then return end

    -- Simulate cutting along the shape's edges
    for i = 1, #cookieShape do
        local currentPoint = cookieShape[i]
        moveMouseTo(currentPoint) -- Move mouse to the current point
        clickMouse() -- Simulate a cut
        task.wait(cuttingSpeed) -- Smooth out the cut speed
    end

    notify("Cookie Cutter", "Shape cut perfectly!")
end

-- UI Integration
local MainTab = Window:CreateTab("Cookie Cutter", 4483362458)

-- Enable Auto Cut Toggle
MainTab:CreateToggle({
    Name = "Enable Auto Cookie Cutter",
    CurrentValue = false,
    Flag = "AutoCutToggle",
    Callback = function(Value)
        cuttingEnabled = Value
        if Value then
            notify("Cookie Cutter", "Auto Cookie Cutter enabled! Waiting for shape...")
        else
            notify("Cookie Cutter", "Auto Cookie Cutter disabled.")
        end
    end
})

-- Cut Speed Slider
MainTab:CreateSlider({
    Name = "Cutting Speed",
    Range = {0.01, 0.1}, -- Min/max cutting speed
    Increment = 0.01,
    CurrentValue = cuttingSpeed,
    Flag = "CutSpeedSlider",
    Callback = function(Value)
        cuttingSpeed = Value
        notify("Cookie Cutter", "Cutting speed set to " .. Value)
    end
})
