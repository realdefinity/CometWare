-- Load Rayfield Library
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Create the Rayfield UI Window
local Window = Rayfield:CreateWindow({
    Name = "COMET: shrimp game edition",
    LoadingTitle = "Loading Shrimp Game...",
    LoadingSubtitle = "By Definity",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "Comet shrimp game", -- Save configs in a folder
        FileName = "ShrimpDominator" -- Config file name
    },
    Discord = {
        Enabled = true,
        Invite = "https://discord.gg/qeFQ57eqtj", -- Replace with your Discord invite if needed
        RememberJoins = true
    }
})

-- üåü Tabs for Features
local MainTab = Window:CreateTab("Main Features", 4483362458) -- Main gameplay features
local VisualsTab = Window:CreateTab("Visuals", 4483362458) -- ESP & visuals
local MovementTab = Window:CreateTab("Movement", 4483362458) -- Speed, jump boosts
local MiscTab = Window:CreateTab("Miscellaneous", 4483362458) -- Other fun stuff

-- üåü Global Variables (Toggle States)
local toggles = {
    espEnabled = false,
    autoWin = false,
    infiniteJump = false,
    speedBoost = false,
    jumpBoost = false
}

-- üåü Function to Notify Players
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- üåü MainTab: Auto Win Toggle
MainTab:CreateToggle({
    Name = "Enable Auto Win",
    CurrentValue = false,
    Flag = "AutoWinToggle",
    Callback = function(Value)
        toggles.autoWin = Value
        notify("Auto Win", "Auto Win has been " .. (Value and "enabled" or "disabled") .. ".")
    end
})


-- üåü MiscTab: Reset All Toggles
MiscTab:CreateButton({
    Name = "Reset All Features",
    Callback = function()
        -- Reset all toggles and states
        for key, _ in pairs(toggles) do
            toggles[key] = false
        end
        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16
        game.Players.LocalPlayer.Character.Humanoid.JumpPower = 50
        notify("Reset Features", "All features have been reset.")
    end
})

-- FPS Booster and Setter with Rayfield UI Integration

-- üåü FPS Booster Variables
local FPSBooster = {}
local toggles = {
    fpsBoostEnabled = false
}
local defaultWalkSpeed = 16 -- Default Roblox walk speed (used in resets)

-- üåü Function to Notify Players
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- üåü FPS Booster Logic
function FPSBooster:Boost()
    -- Optimize Workspace
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") then
            obj.Material = Enum.Material.SmoothPlastic -- Simplify materials
            obj.Reflectance = 0 -- Remove reflections
        elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
            obj.Enabled = false -- Disable particles and trails
        elseif obj:IsA("Beam") then
            obj.Enabled = false -- Disable beams
        elseif obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then
            obj.Enabled = false -- Disable unnecessary lights
        end
    end

    -- Optimize Lighting
    local Lighting = game:GetService("Lighting")
    Lighting.GlobalShadows = false -- Disable global shadows
    Lighting.FogEnd = 9e9 -- Remove fog
    Lighting.Brightness = 1 -- Simplify brightness
    Lighting.EnvironmentSpecularScale = 0 -- Disable specular effects
    Lighting.EnvironmentDiffuseScale = 0 -- Disable diffuse lighting

    -- Disable Terrain Decoration
    if workspace:FindFirstChildOfClass("Terrain") then
        workspace.Terrain.Decoration = false
    end

    -- Notify Player
    notify("FPS Booster", "FPS Booster applied! Performance optimized.")
end

-- üåü FPS Setter Logic
function FPSBooster:SetFPSCap(fps)
    if setfpscap then
        setfpscap(fps)
        notify("FPS Cap", "FPS cap set to " .. tostring(fps) .. " FPS.")
    else
        notify("Error", "Your executor does not support `setfpscap`.")
    end
end

-- üåü UI Integration
VisualsTab:CreateButton({
    Name = "Apply FPS Boost",
    Callback = function()
        FPSBooster:Boost()
    end
})

-- FPS Cap Slider
VisualsTab:CreateSlider({
    Name = "Set FPS Cap",
    Range = {30, 300}, -- Min/Max FPS values
    Increment = 10, -- Adjust in steps of 10
    CurrentValue = 60, -- Default FPS cap
    Flag = "FPSCapSlider",
    Callback = function(Value)
        FPSBooster:SetFPSCap(Value)
    end
})

-- Red Light Green Light Feature
local RedLightGreenLight = {}
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Variables
local reactionTime = 0 -- Reaction time in seconds
local defaultWalkSpeed = 16 -- Default walk speed
local isGreenLight = true -- Current light state
local lightDetectionMethod = "signal" -- Options: "signal" or "timer"

-- Helper: Notify Function
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- Helper: Change Movement State
local function changeMovementState(canMove)
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("Humanoid") then return end

    local humanoid = character:FindFirstChild("Humanoid")
    if canMove then
        humanoid.WalkSpeed = defaultWalkSpeed
    else
        humanoid.WalkSpeed = 0 -- Stop movement
    end
end

-- Light Detection Logic
function RedLightGreenLight:DetectLights()
    if lightDetectionMethod == "signal" then
        -- Example detection (replace with actual game logic if applicable)
        local lightText = game:GetService("Workspace"):FindFirstChild("LightIndicator") -- Example object
        if lightText and lightText:IsA("TextLabel") then
            isGreenLight = lightText.Text == "Green Light"
        end
    elseif lightDetectionMethod == "timer" then
        -- Fallback to timed simulation if no light signals are available
        task.spawn(function()
            while true do
                isGreenLight = not isGreenLight -- Toggle light state
                notify("Light State", "The light is now " .. (isGreenLight and "Green!" or "Red!"))
                task.wait(math.random(3, 6)) -- Random green/red durations
            end
        end)
    end
end

-- Movement Control Logic
function RedLightGreenLight:ControlMovement()
    RunService.Heartbeat:Connect(function()
        local character = LocalPlayer.Character
        if not character or not character:FindFirstChild("Humanoid") then return end

        -- Reaction delay
        task.wait(reactionTime)

        -- Control movement based on light state
        if isGreenLight then
            changeMovementState(true) -- Allow movement
        else
            changeMovementState(false) -- Stop movement
        end
    end)
end

-- Initialize Feature
function RedLightGreenLight:Start()
    notify("Red Light Green Light", "Auto Play enabled!")
    self:DetectLights() -- Start light detection
    self:ControlMovement() -- Control player movement
end

-- Enable Auto Play
MainTab:CreateButton({
    Name = "Start Red Light Green Light",
    Callback = function()
        RedLightGreenLight:Start()
    end
})

-- Reaction Time Slider
MainTab:CreateSlider({
    Name = "Reaction Time",
    Range = {0, 1}, -- 0 for instant reaction, up to 1 second
    Increment = 0.1,
    CurrentValue = 0,
    Flag = "ReactionTimeSlider",
    Callback = function(Value)
        reactionTime = Value
        notify("Reaction Time", "Reaction time set to " .. Value .. " seconds.")
    end
})


-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Variables
local toggles = {
    customSpeedEnabled = false
}
local customSpeed = 16 -- Default speed

-- Helper: Notify Function
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- Anti-Cheat Friendly Custom Speed (CFrame Stepping)
local function applyCustomSpeed()
    if toggles.customSpeedEnabled then
        notify("Custom Speed", "Custom Speed enabled! Moving safely...")
    else
        notify("Custom Speed", "Custom Speed disabled.")
        return
    end

    -- Start applying speed
    RunService.Stepped:Connect(function(_, deltaTime)
        if toggles.customSpeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            local rootPart = LocalPlayer.Character.HumanoidRootPart

            -- Prevent anti-cheat from detecting abnormal movement
            if humanoid and humanoid.MoveDirection.Magnitude > 0 then
                -- Apply small, incremental CFrame changes based on movement direction
                local moveDirection = humanoid.MoveDirection * (customSpeed * deltaTime)
                rootPart.CFrame = rootPart.CFrame + Vector3.new(moveDirection.X, 0, moveDirection.Z)
            end
        end
    end)
end

-- Toggle Custom Speed
MovementTab:CreateToggle({
    Name = "Enable Custom Speed",
    CurrentValue = false,
    Flag = "CustomSpeedToggle",
    Callback = function(Value)
        toggles.customSpeedEnabled = Value
        if Value then
            applyCustomSpeed()
        end
    end
})

-- Speed Slider
MovementTab:CreateSlider({
    Name = "Set Custom Speed",
    Range = {16, 50}, -- Safe speed range
    Increment = 2,
    CurrentValue = 16,
    Flag = "CustomSpeedSlider",
    Callback = function(Value)
        customSpeed = Value
        notify("Custom Speed", "Custom Speed set to " .. Value .. ".")
    end
})

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Variables
local toggles = {
    customJumpEnabled = false
}
local jumpPower = 50 -- Default custom jump height

-- Helper: Notify Function
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- Advanced Anti-Cheat Friendly Jump Logic
local function applyCustomJump()
    UserInputService.JumpRequest:Connect(function()
        if toggles.customJumpEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = LocalPlayer.Character.HumanoidRootPart
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if not humanoid or humanoid.FloorMaterial == Enum.Material.Air then return end -- Ensure we're on the ground

            -- Simulate smooth jump with incremental CFrame adjustments
            for i = 1, jumpPower, 5 do
                task.wait(0.01) -- Small delay for smoothness
                rootPart.CFrame = rootPart.CFrame + Vector3.new(0, 0.5, 0) -- Incrementally move up
            end

            -- Simulate landing
            task.wait(0.1)
            rootPart.CFrame = rootPart.CFrame + Vector3.new(0, -0.5, 0) -- Minor correction to mimic landing
        end
    end)
end

-- Toggle Custom Jump Power
MovementTab:CreateToggle({
    Name = "Enable Custom Jump Power",
    CurrentValue = false,
    Flag = "CustomJumpToggle",
    Callback = function(Value)
        toggles.customJumpEnabled = Value
        if Value then
            applyCustomJump()
            notify("Custom Jump Power", "Custom Jump Power enabled!")
        else
            notify("Custom Jump Power", "Custom Jump Power disabled.")
        end
    end
})

-- Jump Power Slider
MovementTab:CreateSlider({
    Name = "Set Custom Jump Power",
    Range = {10, 100}, -- Safe range for jump height
    Increment = 5,
    CurrentValue = 50,
    Flag = "CustomJumpSlider",
    Callback = function(Value)
        jumpPower = Value
        notify("Custom Jump Power", "Jump Power set to " .. Value .. ".")
    end
})

-- Auto Cookie Cutter Feature
local CookieCutter = {}
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- Variables
local cuttingEnabled = false
local cuttingSpeed = 0.02 -- Adjust this for smoother or faster cuts

-- Helper: Notify Function
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- Helper: Move Mouse to a Position
local function moveMouseTo(position)
    mousemoveabs(position.X, position.Y)
end

-- Helper: Simulate Mouse Press
local function clickMouse()
    mouse1press()
    task.wait(0.1)
    mouse1release()
end

-- Function to Cut Cookie Shape
function CookieCutter:CutCookie(cookieShape)
    if not cuttingEnabled then return end

    -- Simulate cutting along the shape's edges
    for i = 1, #cookieShape do
        local currentPoint = cookieShape[i]
        moveMouseTo(currentPoint) -- Move mouse to the current point
        clickMouse() -- Simulate a cut
        task.wait(cuttingSpeed) -- Smooth out the cut speed
    end

    notify("Cookie Cutter", "Shape cut perfectly!")
end

-- Enable Auto Cut Toggle
MainTab:CreateToggle({
    Name = "Enable Auto Cookie Cutter",
    CurrentValue = false,
    Flag = "AutoCutToggle",
    Callback = function(Value)
        cuttingEnabled = Value
        if Value then
            notify("Cookie Cutter", "Auto Cookie Cutter enabled! Waiting for shape...")
        else
            notify("Cookie Cutter", "Auto Cookie Cutter disabled.")
        end
    end
})

-- Cut Speed Slider
MainTab:CreateSlider({
    Name = "Cutting Speed",
    Range = {0.01, 0.1}, -- Min/max cutting speed
    Increment = 0.01,
    CurrentValue = cuttingSpeed,
    Flag = "CutSpeedSlider",
    Callback = function(Value)
        cuttingSpeed = Value
        notify("Cookie Cutter", "Cutting speed set to " .. Value)
    end
})

-- No-Death Feature
local NoDeath = {}
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Variables
local toggles = {
    noDeathEnabled = false
}

-- Helper: Notify Function
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- üõ°Ô∏è Health Freeze/Restore
local function freezeHealth()
    RunService.Heartbeat:Connect(function()
        if toggles.noDeathEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")

            -- Freeze health
            humanoid.Health = humanoid.MaxHealth

            -- Randomize slight health variation to avoid anti-cheat flags
            if math.random(1, 10) > 8 then
                humanoid.Health = humanoid.Health - 0.01
            end
        end
    end)
end

-- üõ°Ô∏è Damage Blocker
local function blockDamage()
    if not toggles.noDeathEnabled then return end
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("Humanoid") then return end

    local humanoid = character:FindFirstChild("Humanoid")
    humanoid:GetPropertyChangedSignal("Health"):Connect(function()
        if toggles.noDeathEnabled and humanoid.Health < humanoid.MaxHealth then
            humanoid.Health = humanoid.MaxHealth
            notify("No Death", "Blocked incoming damage!")
        end
    end)
end

-- üõ°Ô∏è Respawn Prevention
local function preventRespawnDeath()
    LocalPlayer.CharacterRemoving:Connect(function()
        if toggles.noDeathEnabled then
            notify("No Death", "Respawning immediately!")
            LocalPlayer:LoadCharacter()
        end
    end)
end

-- Initialize Anti-Death Feature
function NoDeath:Start()
    notify("No Death", "No Death mode enabled!")
    freezeHealth()
    blockDamage()
    preventRespawnDeath()
end

-- Enable No Death Toggle
MainTab:CreateToggle({
    Name = "Enable No Death",
    CurrentValue = false,
    Flag = "NoDeathToggle",
    Callback = function(Value)
        toggles.noDeathEnabled = Value
        if Value then
            NoDeath:Start()
        else
            notify("No Death", "No Death mode disabled.")
        end
    end
})


-- Advanced Glass Bridge Solver
local GlassBridgeSolver = {}
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

-- Variables
local autoCrossEnabled = false
local highlightEnabled = true -- Highlights safe tiles
local tileDetectionMethod = "transparency" -- Change as needed: "transparency", "name", "proximity", "raycast"
local safeColor = Color3.fromRGB(0, 255, 0) -- Green for safe tiles
local unsafeColor = Color3.fromRGB(255, 0, 0) -- Red for unsafe tiles

-- Helper: Notify Function
local function notify(title, content)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = 5,
        Actions = {
            Dismiss = {
                Name = "OK",
                Callback = function() end
            }
        }
    })
end

-- Helper: Highlight a Tile
local function highlightTile(tile, color)
    if not tile:FindFirstChild("Highlight") then
        local highlight = Instance.new("BoxHandleAdornment")
        highlight.Adornee = tile
        highlight.Size = tile.Size
        highlight.Color3 = color
        highlight.AlwaysOnTop = true
        highlight.ZIndex = 10
        highlight.Parent = tile
    else
        tile.Highlight.Color3 = color
    end
end

-- Function to Detect Safe Tiles
function GlassBridgeSolver:DetectSafeTiles()
    local tiles = {} -- Store detected safe tiles
    for _, tile in pairs(workspace:GetDescendants()) do
        if tile:IsA("Part") and tile.Name:match("Glass") then -- Adjust this based on the game's naming
            if tileDetectionMethod == "transparency" then
                -- Check tile transparency (e.g., unsafe tiles may be more transparent)
                if tile.Transparency < 0.5 then
                    table.insert(tiles, {tile = tile, isSafe = true})
                    if highlightEnabled then
                        highlightTile(tile, safeColor)
                    end
                else
                    if highlightEnabled then
                        highlightTile(tile, unsafeColor)
                    end
                end
            elseif tileDetectionMethod == "name" then
                -- Example: Tiles named "Safe" are safe
                if tile.Name:lower():find("safe") then
                    table.insert(tiles, {tile = tile, isSafe = true})
                    if highlightEnabled then
                        highlightTile(tile, safeColor)
                    end
                else
                    if highlightEnabled then
                        highlightTile(tile, unsafeColor)
                    end
                end
            elseif tileDetectionMethod == "proximity" then
                -- Example: Proximity detection for safe tiles
                local proximity = tile:FindFirstChild("ProximityPrompt")
                if proximity then
                    table.insert(tiles, {tile = tile, isSafe = true})
                    if highlightEnabled then
                        highlightTile(tile, safeColor)
                    end
                else
                    if highlightEnabled then
                        highlightTile(tile, unsafeColor)
                    end
                end
            elseif tileDetectionMethod == "raycast" then
                -- Example: Raycast downward to test for safety
                local ray = Ray.new(tile.Position, Vector3.new(0, -10, 0))
                local hit = workspace:FindPartOnRay(ray)
                if hit and hit == tile then
                    table.insert(tiles, {tile = tile, isSafe = true})
                    if highlightEnabled then
                        highlightTile(tile, safeColor)
                    end
                else
                    if highlightEnabled then
                        highlightTile(tile, unsafeColor)
                    end
                end
            end
        end
    end
    return tiles
end

-- Function to Auto Cross the Bridge
function GlassBridgeSolver:AutoCross()
    if not autoCrossEnabled then return end

    local safeTiles = self:DetectSafeTiles()
    for _, info in pairs(safeTiles) do
        if info.isSafe and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            humanoid:MoveTo(info.tile.Position + Vector3.new(0, 3, 0)) -- Move above the tile
            task.wait(0.5) -- Wait before moving to the next tile
        end
    end
end

-- Enable Auto Cross Toggle
MainTab:CreateToggle({
    Name = "Enable Auto Cross",
    CurrentValue = false,
    Flag = "AutoCrossToggle",
    Callback = function(Value)
        autoCrossEnabled = Value
        if Value then
            notify("Glass Bridge Solver", "Auto Cross enabled! Crossing the bridge...")
            task.spawn(function()
                while autoCrossEnabled do
                    GlassBridgeSolver:AutoCross()
                    task.wait(1)
                end
            end)
        else
            notify("Glass Bridge Solver", "Auto Cross disabled.")
        end
    end
})

-- Enable Highlights Toggle
MainTab:CreateToggle({
    Name = "Enable Highlights",
    CurrentValue = true,
    Flag = "HighlightToggle",
    Callback = function(Value)
        highlightEnabled = Value
        notify("Glass Bridge Solver", "Tile highlighting " .. (Value and "enabled." or "disabled."))
    end
})

