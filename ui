--[[ 
   =============================================
   Usage Example (after running this script):
   
       local myTab = _G.baseWindow:AddTab("Player")
       local mySection = myTab:AddSection("Speed Settings")
       mySection:AddSlider({ Label = "Walk Speed", Min = 16, Max = 100, Default = 16, Size = UDim2.new(0,300,0,60) }, function(value)
           local player = game:GetService("Players").LocalPlayer
           local character = player.Character or player.CharacterAdded:Wait()
           local humanoid = character:FindFirstChildOfClass("Humanoid")
           if humanoid then
               humanoid.WalkSpeed = value
           end
           print("Walk Speed changed to:", value)
       end)
       mySection:AddToggle({ Label = "God Mode", Default = false, Size = UDim2.new(0,300,0,40) }, function(state)
           print("God Mode:", state)
       end)
       mySection:AddButton({ Text = "Reset", Size = UDim2.new(0,300,0,50) }, function()
           print("Reset clicked!")
       end)
       
   Made and developed by Definity.
--]]

---------------------------
-- SERVICES & UTILITY FUNCTIONS
---------------------------
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Modified tween function now supports an optional callback
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
    local info = TweenInfo.new(
        duration or 0.2,
        easingStyle or Enum.EasingStyle.Sine,
        easingDirection or Enum.EasingDirection.Out,
        0,
        false,
        delay or 0
    )
    local tw = TweenService:Create(object, info, properties)
    if callback then
        tw.Completed:Connect(callback)
    end
    tw:Play()
    return tw
end

---------------------------
-- UI ELEMENT FUNCTIONS
---------------------------


--[[ 
  Insert the following function into your WindowAPI code.
  For example, in your WindowAPI module you might have:
  
  function section:AddSlider(opts, callback)
      createSlider(section.Frame, opts, callback)
  end
--]]

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

--------------------------------------------------
-- Tween helper (for non‐continuous animations)
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
    local info = TweenInfo.new(
        duration or 0.25,
        easingStyle or Enum.EasingStyle.Quint,
        easingDirection or Enum.EasingDirection.Out,
        0,
        false,
        delay or 0
    )
    local tw = TweenService:Create(object, info, properties)
    if callback then
        tw.Completed:Connect(callback)
    end
    tw:Play()
    return tw
end

--------------------------------------------------
-- createSlider function
--------------------------------------------------
local function createSlider(parent, opts, callback)
    opts = opts or {}
    local min = opts.Min or 0
    local max = opts.Max or 100
    local defaultValue = opts.Default or 50
    local sliderLabel = opts.Label or "Slider"
    local initPercent = (defaultValue - min) / (max - min)
    
    -- Outer container (slider)
    local slider = Instance.new("Frame")
    slider.Name = "Slider"
    slider.Size = opts.Size or UDim2.new(0, 300, 0, 130)
    slider.BackgroundTransparency = 1
    slider.ClipsDescendants = true  -- ensures nothing spills out unexpectedly
    slider.ZIndex = 10
    slider.Parent = parent

    -- UIScale for a subtle pop on hover
    local scaleObj = Instance.new("UIScale", slider)
    scaleObj.Scale = 1

    -- UIStroke for the animated border
    local containerStroke = Instance.new("UIStroke", slider)
    containerStroke.Color = Color3.fromRGB(100, 100, 100)
    containerStroke.Thickness = 2
    containerStroke.Transparency = 0.3

    -----------------------------------
    -- Shine Overlay (for hover effect)
    -----------------------------------
    -- This frame is parented directly to the slider so it is not affected by the layout.
    local shine = Instance.new("Frame")
    shine.Name = "Shine"
    shine.Size = UDim2.new(1, 0, 1, 0)
    shine.Position = UDim2.new(0, 0, 0, 0)
    shine.BackgroundTransparency = 1
    -- Set the ZIndex so the shine appears behind the content.
    shine.ZIndex = slider.ZIndex 
    shine.Visible = false
    shine.Parent = slider

    local shineGradient = Instance.new("UIGradient", shine)
    shineGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(0.5, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))
    })
    shineGradient.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),    -- transparent at the left edge
        NumberSequenceKeypoint.new(0.5, 0.3),-- subtle highlight in the middle
        NumberSequenceKeypoint.new(1, 1)     -- transparent at the right edge
    })
    shineGradient.Rotation = 0  -- horizontal gradient
    shineGradient.Offset = Vector2.new(1, 0)

    -----------------------------------
    -- Content Container (holds all UI elements)
    -----------------------------------
    local content = Instance.new("Frame")
    content.Name = "Content"
    content.Size = UDim2.new(1, 0, 1, 0)
    content.Position = UDim2.new(0, 0, 0, 0)
    content.BackgroundTransparency = 1
    -- Place content above the shine
    content.ZIndex = slider.ZIndex + 1
    content.Parent = slider

    local padding = Instance.new("UIPadding", content)
    padding.PaddingLeft = UDim.new(0, 10)
    padding.PaddingRight = UDim.new(0, 10)
    padding.PaddingTop = UDim.new(0, 10)
    padding.PaddingBottom = UDim.new(0, 10)

    local layout = Instance.new("UIListLayout", content)
    layout.FillDirection = Enum.FillDirection.Vertical
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Padding = UDim.new(0, 5)

    -- Title Label
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Size = UDim2.new(1, 0, 0, 35)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = sliderLabel
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextSize = 26
    titleLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.TextStrokeTransparency = 0.8
    titleLabel.ZIndex = content.ZIndex
    titleLabel.Parent = content

    -- Value Label
    local valueLabel = Instance.new("TextLabel")
    valueLabel.Name = "ValueLabel"
    valueLabel.Size = UDim2.new(1, 0, 0, 25)
    valueLabel.BackgroundTransparency = 1
    valueLabel.Text = tostring(defaultValue)
    valueLabel.Font = Enum.Font.GothamSemibold
    valueLabel.TextSize = 22
    valueLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
    valueLabel.TextXAlignment = Enum.TextXAlignment.Left
    valueLabel.TextStrokeTransparency = 0.8
    valueLabel.ZIndex = content.ZIndex
    valueLabel.Parent = content

    -- Track (slider bar)
    local track = Instance.new("Frame")
    track.Name = "Track"
    track.Size = UDim2.new(1, -20, 0, 12)  -- inset 10px each side
    track.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    track.BorderSizePixel = 0
    track.ZIndex = content.ZIndex
    track.Parent = content
    local trackCorner = Instance.new("UICorner", track)
    trackCorner.CornerRadius = UDim.new(0, 6)
    local trackGradient = Instance.new("UIGradient", track)
    trackGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 80, 80)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 60, 60))
    })
    trackGradient.Rotation = 90

    -- Fill inside the track (indicates current value)
    local fill = Instance.new("Frame")
    fill.Name = "Fill"
    fill.Size = UDim2.new(initPercent, 0, 1, 0)
    fill.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
    fill.BorderSizePixel = 0
    fill.ZIndex = track.ZIndex + 1
    fill.Parent = track
    local fillCorner = Instance.new("UICorner", fill)
    fillCorner.CornerRadius = UDim.new(0, 6)
    local fillGradient = Instance.new("UIGradient", fill)
    fillGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 180, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 120, 255))
    })
    fillGradient.Rotation = 90

    -- Draggable Handle
    local handle = Instance.new("TextButton")
    handle.Name = "Handle"
    handle.Size = UDim2.new(0, 20, 0, 20)
    handle.AnchorPoint = Vector2.new(0.5, 0.5)
    handle.Position = UDim2.new(initPercent, 0, 0.5, 0)
    handle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    handle.BorderSizePixel = 0
    handle.AutoButtonColor = false
    handle.Text = ""
    handle.ZIndex = track.ZIndex + 2
    handle.Parent = track
    local handleCorner = Instance.new("UICorner", handle)
    handleCorner.CornerRadius = UDim.new(1, 0)
    local handleStroke = Instance.new("UIStroke", handle)
    handleStroke.Color = Color3.fromRGB(0, 150, 255)
    handleStroke.Thickness = 2
    handleStroke.Transparency = 0.5

    -----------------------------------
    -- Smooth interpolation for fill & handle
    -----------------------------------
    local targetPercent = initPercent
    local currentPercent = initPercent
    local renderConn = RunService.RenderStepped:Connect(function()
        if slider and slider.Parent then
            currentPercent = currentPercent + (targetPercent - currentPercent) * 0.6
            fill.Size = UDim2.new(currentPercent, 0, 1, 0)
            handle.Position = UDim2.new(currentPercent, 0, 0.5, 0)
        else
            renderConn:Disconnect()
        end
    end)

    -----------------------------------
    -- Dragging logic and updating value
    -----------------------------------
    local dragging = false
    local function updateValueFromInput(input)
        local absX = track.AbsolutePosition.X
        local width = track.AbsoluteSize.X
        local mouseX = input.Position.X
        local pos = math.clamp(mouseX - absX, 0, width)
        local percent = pos / width
        targetPercent = percent
        local value = math.floor(min + (max - min) * percent)
        valueLabel.Text = tostring(value)
        if callback then
            callback(value)
        end
    end

    handle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            tween(handle, {Size = UDim2.new(0, 26, 0, 26)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
        end
    end)

    handle.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
            tween(handle, {Size = UDim2.new(0, 20, 0, 20)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
        end
    end)

    track.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            updateValueFromInput(input)
            tween(handle, {Size = UDim2.new(0, 26, 0, 26)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, function()
                if not dragging then
                    tween(handle, {Size = UDim2.new(0, 20, 0, 20)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
                end
            end)
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            updateValueFromInput(input)
        end
    end)

    -----------------------------------
    -- Hover animation for the container (slider)
    -----------------------------------
    local shineTween
    local function startShineTween()
        shineGradient.Offset = Vector2.new(1, 0)
        -- Tween from right (Offset = (1,0)) to left (Offset = (-1,0)) over 5 seconds
        shineTween = tween(shineGradient, {Offset = Vector2.new(-1, 0)}, 5, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
        shineTween.Completed:Connect(function()
            if shine.Visible then
                startShineTween()  -- loop the tween
            end
        end)
    end

    slider.Active = true
    slider.MouseEnter:Connect(function()
        tween(containerStroke, {Thickness = 4, Color = Color3.fromRGB(0, 150, 255), Transparency = 0}, 0.25)
        tween(scaleObj, {Scale = 1.03}, 0.25)
        shine.Visible = true
        startShineTween()
    end)

    slider.MouseLeave:Connect(function()
        tween(containerStroke, {Thickness = 2, Color = Color3.fromRGB(100, 100, 100), Transparency = 0.3}, 0.25)
        tween(scaleObj, {Scale = 1}, 0.25)
        if shineTween then
            shineTween:Cancel()
            shineTween = nil
        end
        shine.Visible = false
        shineGradient.Offset = Vector2.new(1, 0)
    end)

    return slider
end

local TweenService = game:GetService("TweenService")

--------------------------------------------------
-- Helper tween function using exponential easing.
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
    local info = TweenInfo.new(
        duration or 0.3,
        easingStyle or Enum.EasingStyle.Exponential,
        easingDirection or Enum.EasingDirection.Out,
        0,
        false,
        delay or 0
    )
    local tw = TweenService:Create(object, info, properties)
    if callback then
        tw.Completed:Connect(callback)
    end
    tw:Play()
    return tw
end

--------------------------------------------------
-- Redesigned Toggle Function with Animated Border
--------------------------------------------------
local function createToggle(parent, opts, callback)
    opts = opts or {}
    local labelText = opts.Label or "Toggle"
    local defaultState = opts.Default or false

    -- Container: Ensures extendability without overlap.
    local container = Instance.new("Frame")
    container.Name = "ToggleContainer"
    container.Size = opts.Size or UDim2.new(1, 0, 0, 40)
    container.BackgroundTransparency = 1
    container.AutomaticSize = Enum.AutomaticSize.Y
    container.Parent = parent

    -- Label (left side)
    local label = Instance.new("TextLabel")
    label.Name = "ToggleLabel"
    label.Size = UDim2.new(0.65, 0, 1, 0)
    label.Position = UDim2.new(0, 10, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.Font = Enum.Font.GothamBold
    label.TextSize = 20
    label.TextColor3 = Color3.fromRGB(240, 240, 240)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = container

    -- Toggle track (right side)
    local track = Instance.new("Frame")
    track.Name = "ToggleTrack"
    track.Size = UDim2.new(0, 60, 0, 30)
    track.AnchorPoint = Vector2.new(1, 0.5)
    track.Position = UDim2.new(1, -10, 0.5, 0)
    track.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    track.BorderSizePixel = 0
    track.Parent = container
    local trackCorner = Instance.new("UICorner", track)
    trackCorner.CornerRadius = UDim.new(0, 15)

    -- Add a subtle gradient on the track for depth.
    local trackGradient = Instance.new("UIGradient", track)
    trackGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(40, 40, 40)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 60, 60))
    })
    trackGradient.Rotation = 90

    -- Add an animated border around the track using UIStroke.
    local borderStroke = Instance.new("UIStroke", track)
    borderStroke.Color = Color3.fromRGB(100, 100, 100)
    borderStroke.Thickness = 2
    borderStroke.Transparency = 0.5

    -- Glow frame (for extra visual flair when toggled on)
    local glow = Instance.new("Frame")
    glow.Name = "ToggleGlow"
    glow.Size = UDim2.new(1, 6, 1, 6)
    glow.Position = UDim2.new(0, -3, 0, -3)
    glow.BackgroundColor3 = Color3.fromRGB(0, 180, 255)
    glow.BackgroundTransparency = 1  -- starts hidden
    glow.Parent = track
    local glowCorner = Instance.new("UICorner", glow)
    glowCorner.CornerRadius = UDim.new(0, 15)

    -- Toggle handle (the sliding indicator)
    local handle = Instance.new("Frame")
    handle.Name = "ToggleHandle"
    handle.Size = UDim2.new(0, 26, 0, 26)
    handle.BackgroundColor3 = defaultState and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(200, 200, 200)
    handle.BorderSizePixel = 0
    handle.Parent = track
    local handleCorner = Instance.new("UICorner", handle)
    handleCorner.CornerRadius = UDim.new(1, 0)
    -- Define positions for off and on states.
    local offPosition = UDim2.new(0, 2, 0.5, -13)
    local onPosition  = UDim2.new(1, -28, 0.5, -13)
    handle.Position = defaultState and onPosition or offPosition

    -- Optional: Add a shadow for depth.
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "HandleShadow"
    shadow.Size = handle.Size
    shadow.Position = UDim2.new(0, 2, 0, 2)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://131604521"  -- Replace with your asset if desired
    shadow.ImageColor3 = Color3.new(0, 0, 0)
    shadow.ImageTransparency = 0.5
    shadow.Parent = handle
    shadow.ZIndex = handle.ZIndex - 1

    local state = defaultState

    --------------------------------------------------
    -- Function to update the toggle state.
    --------------------------------------------------
    local function updateToggle(newState)
        state = newState
        if state then
            tween(handle, {Position = onPosition}, 0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
            tween(track, {BackgroundColor3 = Color3.fromRGB(0, 180, 255)}, 0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
            tween(handle, {BackgroundColor3 = Color3.fromRGB(255, 255, 255)}, 0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
            tween(glow, {BackgroundTransparency = 0.4}, 0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
            tween(borderStroke, {Color = Color3.fromRGB(0, 180, 255), Thickness = 4, Transparency = 0}, 0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
        else
            tween(handle, {Position = offPosition}, 0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
            tween(track, {BackgroundColor3 = Color3.fromRGB(50, 50, 50)}, 0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
            tween(handle, {BackgroundColor3 = Color3.fromRGB(200, 200, 200)}, 0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
            tween(glow, {BackgroundTransparency = 1}, 0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
            tween(borderStroke, {Color = Color3.fromRGB(100, 100, 100), Thickness = 2, Transparency = 0.5}, 0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
        end
        if callback then
            callback(state)
        end
    end

    --------------------------------------------------
    -- Connect mouse input: Toggle when the track is clicked.
    --------------------------------------------------
    track.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            updateToggle(not state)
        end
    end)

    return container
end


-- Button: creates a button with a ripple effect.
local TweenService = game:GetService("TweenService")

-- Utility tween function for smooth transitions
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.15,
		easingStyle or Enum.EasingStyle.Sine,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

-- Create a super-smooth, ultra-clean button.
-- You can pass custom options in the "opts" table to override default styles.
local function createButton(parent, opts, callback)
	opts = opts or {}

	-- Create the main button
	local button = Instance.new("TextButton")
	button.Name = opts.Name or "SmoothButton"
	button.Size = opts.Size or UDim2.new(0, 150, 0, 50)
	button.Position = opts.Position or UDim2.new(0, 0, 0, 0)
	button.BackgroundColor3 = opts.BackgroundColor or Color3.fromRGB(0, 150, 255)
	button.Text = opts.Text or "Button"
	button.Font = opts.Font or Enum.Font.GothamBold
	button.TextSize = opts.TextSize or 18
	button.TextColor3 = opts.TextColor or Color3.fromRGB(240, 240, 240)
	button.AutoButtonColor = false
	button.Parent = parent

	-- Optional drop shadow for extra depth (set opts.DropShadow = true to enable)
	if opts.DropShadow then
		local shadow = Instance.new("Frame")
		shadow.Name = "DropShadow"
		shadow.Size = button.Size
		shadow.Position = UDim2.new(0, opts.ShadowOffsetX or 3, 0, opts.ShadowOffsetY or 3)
		shadow.BackgroundColor3 = opts.ShadowColor or Color3.new(0, 0, 0)
		shadow.BackgroundTransparency = opts.ShadowTransparency or 0.5
		shadow.ZIndex = button.ZIndex - 1
		shadow.Parent = button

		local shadowCorner = Instance.new("UICorner")
		shadowCorner.CornerRadius = opts.CornerRadius or UDim.new(0, 12)
		shadowCorner.Parent = shadow
	end

	-- Rounded corners for a modern look
	local corner = Instance.new("UICorner")
	corner.CornerRadius = opts.CornerRadius or UDim.new(0, 12)
	corner.Parent = button

	-- Stroke for a subtle outline
	local stroke = Instance.new("UIStroke")
	stroke.Thickness = opts.StrokeThickness or 2
	stroke.Color = opts.StrokeColor or Color3.fromRGB(0, 120, 200)
	stroke.Transparency = opts.StrokeTransparency or 0.4
	stroke.Parent = button

	-- Gradient for a dynamic background effect
	local gradient = Instance.new("UIGradient")
	gradient.Color = opts.GradientColor or ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 170, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 130, 255))
	})
	gradient.Rotation = opts.GradientRotation or 90
	gradient.Parent = button

	-- UIScale for scaling animations (used on click)
	local scale = Instance.new("UIScale")
	scale.Scale = 1
	scale.Parent = button

	-- Hover Effects
	button.MouseEnter:Connect(function()
		tween(button, { BackgroundColor3 = opts.HoverColor or Color3.fromRGB(0, 180, 255) }, 0.15)
		tween(stroke, { Transparency = opts.StrokeHoverTransparency or 0.2 }, 0.15)
		tween(gradient, { Rotation = opts.GradientHoverRotation or 0 }, 0.15)
	end)

	button.MouseLeave:Connect(function()
		tween(button, { BackgroundColor3 = opts.BackgroundColor or Color3.fromRGB(0, 150, 255) }, 0.15)
		tween(stroke, { Transparency = opts.StrokeTransparency or 0.4 }, 0.15)
		tween(gradient, { Rotation = opts.GradientRotation or 90 }, 0.15)
	end)

	-- Click effects: scale down then flash with a ripple
	button.MouseButton1Down:Connect(function()
		tween(scale, { Scale = opts.PressScale or 0.95 }, 0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	end)

	button.MouseButton1Up:Connect(function()
		tween(scale, { Scale = 1 }, 0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		
		-- Create flash (ripple) effect on click
		local flash = Instance.new("Frame")
		flash.Size = UDim2.new(0, 0, 0, 0)
		flash.AnchorPoint = Vector2.new(0.5, 0.5)
		flash.Position = UDim2.new(0.5, 0, 0.5, 0)
		flash.BackgroundColor3 = opts.FlashColor or Color3.fromRGB(255, 255, 255)
		flash.BackgroundTransparency = opts.FlashTransparency or 0.3
		flash.ZIndex = button.ZIndex + 1
		flash.Parent = button

		local flashCorner = Instance.new("UICorner")
		flashCorner.CornerRadius = corner.CornerRadius
		flashCorner.Parent = flash

		tween(flash, { Size = UDim2.new(1.5, 0, 1.5, 0), BackgroundTransparency = 1 }, 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, function()
			flash:Destroy()
		end)

		if callback then
			callback()
		end
	end)

	return button
end

---------------------------
-- Base UI Window & Tab System with Sections
---------------------------
-- If an older version exists, remove it.
if game.CoreGui:FindFirstChild("CometUI") then
    game.CoreGui:FindFirstChild("CometUI"):Destroy()
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CometUI"
screenGui.Parent = game.CoreGui
screenGui.IgnoreGuiInset = true

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Parent = screenGui
mainFrame.Size = UDim2.new(0,500,0,400)
mainFrame.Position = UDim2.new(0.5,0,0.5,0)
mainFrame.AnchorPoint = Vector2.new(0.5,0.5)
mainFrame.BackgroundColor3 = Color3.fromRGB(35,35,35)
mainFrame.BorderSizePixel = 0
local mainCorner = Instance.new("UICorner", mainFrame)
mainCorner.CornerRadius = UDim.new(0,12)
local mainGradient = Instance.new("UIGradient", mainFrame)
mainGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(45,45,45)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(35,35,35))
}

local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Parent = mainFrame
titleBar.Size = UDim2.new(1,0,0,30)
titleBar.BackgroundColor3 = Color3.fromRGB(30,30,30)
titleBar.BorderSizePixel = 0
local titleBarCorner = Instance.new("UICorner", titleBar)
titleBarCorner.CornerRadius = UDim.new(0,12)

local titleText = Instance.new("TextLabel")
titleText.Name = "TitleText"
titleText.Parent = titleBar
titleText.Size = UDim2.new(1,0,1,0)
titleText.BackgroundTransparency = 1
titleText.Text = "CometWare"
titleText.TextColor3 = Color3.fromRGB(240,240,240)
titleText.Font = Enum.Font.GothamBold
titleText.TextSize = 20
titleText.TextStrokeTransparency = 0.85
titleText.Position = UDim2.new(0.02,0,0,0)

local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Parent = titleBar
closeButton.Size = UDim2.new(0,30,0,30)
closeButton.Position = UDim2.new(1,-30,0,0)
closeButton.BackgroundColor3 = Color3.fromRGB(200,80,80)
closeButton.Text = "X"
closeButton.TextColor3 = Color3.fromRGB(240,240,240)
closeButton.Font = Enum.Font.GothamBold
closeButton.TextSize = 16
local closeCorner = Instance.new("UICorner", closeButton)
closeCorner.CornerRadius = UDim.new(0,5)
closeButton.MouseButton1Click:Connect(function()
    tween(mainFrame, {BackgroundTransparency = 1}, 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, function()
        screenGui:Destroy()
    end)
end)

-- Draggability using the title bar.
local dragging = false
local dragInput, dragStart, startPos
titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then dragging = false end
        end)
    end
end)
titleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then dragInput = input end
end)
UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        local delta = input.Position - dragStart
        mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

-- Tab System Containers.
local tabButtonsFrame = Instance.new("Frame")
tabButtonsFrame.Name = "TabButtonsFrame"
tabButtonsFrame.Parent = mainFrame
tabButtonsFrame.Size = UDim2.new(1,0,0,40)
tabButtonsFrame.Position = UDim2.new(0,0,0,30)
tabButtonsFrame.BackgroundTransparency = 1

local tabContentFrame = Instance.new("Frame")
tabContentFrame.Name = "TabContentFrame"
tabContentFrame.Parent = mainFrame
tabContentFrame.Size = UDim2.new(1,0,1,-70)
tabContentFrame.Position = UDim2.new(0,0,0,70)
tabContentFrame.BackgroundTransparency = 1

---------------------------
-- Build the base window API.
---------------------------
local windowAPI = {}
windowAPI.TabButtonsFrame = tabButtonsFrame
windowAPI.TabContentFrame = tabContentFrame
windowAPI.Tabs = {}
windowAPI.ActiveTab = nil

local TweenService = game:GetService("TweenService")

-- A general tween helper function.
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.15,
		easingStyle or Enum.EasingStyle.Sine,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

local function createTab(windowAPI, tabName)
	local tab = {}
	tab.Name = tabName
	tab.Sections = {}

	---------------------------------------------------
	-- Ensure the TabButtonsFrame has a horizontal layout
	---------------------------------------------------
	local tabButtonsFrame = windowAPI.TabButtonsFrame
	if not tabButtonsFrame:FindFirstChildOfClass("UIListLayout") then
		local listLayout = Instance.new("UIListLayout")
		listLayout.FillDirection = Enum.FillDirection.Horizontal
		listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
		listLayout.VerticalAlignment = Enum.VerticalAlignment.Center
		listLayout.Padding = UDim.new(0, 5)
		listLayout.Parent = tabButtonsFrame
	end

	-----------------------------
	-- Create the tab button:
	-----------------------------
	local tabButton = Instance.new("TextButton")
	tabButton.Name = "TabButton"
	tabButton.Text = tabName
	tabButton.Size = UDim2.new(0, 100, 1, 0)
	tabButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	tabButton.TextColor3 = Color3.fromRGB(240, 240, 240)
	tabButton.Font = Enum.Font.GothamBold
	tabButton.TextSize = 16
	tabButton.AutoButtonColor = false
	tabButton.Parent = tabButtonsFrame

	-- Add smooth rounded corners.
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = tabButton

	-- Add an active indicator (a thin line at the bottom).
	local indicator = Instance.new("Frame")
	indicator.Name = "ActiveIndicator"
	indicator.Size = UDim2.new(1, 0, 0, 2)
	indicator.Position = UDim2.new(0, 0, 1, -2)
	indicator.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	indicator.BackgroundTransparency = 1  -- hidden by default
	indicator.Parent = tabButton

	-----------------------------
	-- Create the tab content:
	-----------------------------
	local tabContent = Instance.new("ScrollingFrame")
	tabContent.Name = "TabContent_" .. tabName
	tabContent.Size = UDim2.new(1, -10, 1, -10)
	tabContent.Position = UDim2.new(0, 5, 0, 5)
	tabContent.BackgroundTransparency = 1
	tabContent.ScrollBarThickness = 4
	tabContent.Visible = false
	tabContent.Parent = windowAPI.TabContentFrame

	-- Add a layout to organize content vertically.
	local listLayout = Instance.new("UIListLayout", tabContent)
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 5)

	-----------------------------
	-- Add Hover & Active Effects:
	-----------------------------
	tabButton.MouseEnter:Connect(function()
		if windowAPI.ActiveTab ~= tab then
			tween(tabButton, { BackgroundColor3 = Color3.fromRGB(70, 70, 70) }, 0.15)
		end
	end)

	tabButton.MouseLeave:Connect(function()
		if windowAPI.ActiveTab ~= tab then
			tween(tabButton, { BackgroundColor3 = Color3.fromRGB(60, 60, 60) }, 0.15)
		end
	end)

	-- When a tab is clicked, tween its colors and indicator, hide other tabs’ content,
	-- and mark this one as active.
	tabButton.MouseButton1Click:Connect(function()
		-- Loop through all tabs and reset them.
		for _, t in pairs(windowAPI.Tabs) do
			if t.Button then
				tween(t.Button, { BackgroundColor3 = Color3.fromRGB(60, 60, 60) }, 0.15)
				local ind = t.Button:FindFirstChild("ActiveIndicator")
				if ind then
					tween(ind, { BackgroundTransparency = 1 }, 0.15)
				end
			end
			if t.Content then
				t.Content.Visible = false
			end
		end

		-- Mark this tab as active with a gentle color change and reveal its indicator.
		tween(tabButton, { BackgroundColor3 = Color3.fromRGB(80, 80, 80) }, 0.15)
		if tabButton:FindFirstChild("ActiveIndicator") then
			tween(tabButton.ActiveIndicator, { BackgroundTransparency = 0 }, 0.15)
		end

		tabContent.Visible = true
		windowAPI.ActiveTab = tab
	end)

	-- If no active tab exists yet, initialize with this one.
	if windowAPI.ActiveTab then
		tabContent.Visible = false
	else
		windowAPI.ActiveTab = tab
		tabContent.Visible = true
		tween(tabButton, { BackgroundColor3 = Color3.fromRGB(80, 80, 80) }, 0.15)
		if tabButton:FindFirstChild("ActiveIndicator") then
			tween(tabButton.ActiveIndicator, { BackgroundTransparency = 0 }, 0.15)
		end
	end

	tab.Button = tabButton
	tab.Content = tabContent

	-----------------------------
	-- Allow adding sections:
	-----------------------------
	function tab:AddSection(sectionName)
		local section = {}
		section.Name = sectionName

		local sectionFrame = Instance.new("Frame")
		sectionFrame.Name = "Section_" .. sectionName
		sectionFrame.Size = UDim2.new(1, 0, 0, 100)  -- default height; adjust as needed
		sectionFrame.BackgroundTransparency = 1
		sectionFrame.Parent = tabContent

		-- Use a layout to neatly stack elements.
		local sectionLayout = Instance.new("UIListLayout", sectionFrame)
		sectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
		sectionLayout.Padding = UDim.new(0, 5)

		section.Frame = sectionFrame

		-- These functions assume that you have createSlider, createToggle, and createButton defined.
		function section:AddSlider(opts, callback)
			createSlider(sectionFrame, opts, callback)
		end
		function section:AddToggle(opts, callback)
			createToggle(sectionFrame, opts, callback)
		end
		function section:AddButton(opts, callback)
			createButton(sectionFrame, opts, callback)
		end

		table.insert(tab.Sections, section)
		return section
	end

	table.insert(windowAPI.Tabs, tab)
	return tab
end

-- Add a new tab via your windowAPI.
function windowAPI:AddTab(tabName)
	return createTab(self, tabName)
end

---------------------------
-- UI Visibility Toggle (RightShift)
---------------------------
local uiVisible = true
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.RightShift then
        uiVisible = not uiVisible
        local mainFrameRef = game.CoreGui:FindFirstChild("CometUI") and game.CoreGui.CometUI:FindFirstChild("MainFrame")
        if mainFrameRef then
            if uiVisible then
                mainFrameRef.Visible = true
                tween(mainFrameRef, {BackgroundTransparency = 0}, 0.3, Enum.EasingStyle.Sine)
            else
                tween(mainFrameRef, {BackgroundTransparency = 1}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, function()
                    mainFrameRef.Visible = false
                end)
            end
        end
    end
end)

---------------------------
-- Expose the Base Window API Globally via a CometUI module
---------------------------
local CometUI = {}
function CometUI:CreateWindow(config)
    if config then
        if config.Title then
            titleText.Text = config.Title
        end
        if config.Size then
            mainFrame.Size = config.Size
            mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
        end
    end
    return windowAPI
end

_G.baseWindow = CometUI:CreateWindow({ Title = "CometWare", Size = UDim2.new(0,500,0,400) })
print("Base UI created. Use _G.baseWindow:AddTab('Tab Name') to add a new tab.")
