
---------------------------
-- SERVICES & UTILITY FUNCTIONS
---------------------------
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Modified tween function now supports an optional callback
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
    local info = TweenInfo.new(
        duration or 0.2,
        easingStyle or Enum.EasingStyle.Sine,
        easingDirection or Enum.EasingDirection.Out,
        0,
        false,
        delay or 0
    )
    local tw = TweenService:Create(object, info, properties)
    if callback then
        tw.Completed:Connect(callback)
    end
    tw:Play()
    return tw
end

---------------------------
-- UI ELEMENT FUNCTIONS
---------------------------


--[[ 
  Insert the following function into your WindowAPI code.
  For example, in your WindowAPI module you might have:
  
  function section:AddSlider(opts, callback)
      createSlider(section.Frame, opts, callback)
  end
--]]

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

--------------------------------------------------
-- Tween helper (for non‐continuous animations)
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
    local info = TweenInfo.new(
        duration or 0.25,
        easingStyle or Enum.EasingStyle.Quint,
        easingDirection or Enum.EasingDirection.Out,
        0,
        false,
        delay or 0
    )
    local tw = TweenService:Create(object, info, properties)
    if callback then
        tw.Completed:Connect(callback)
    end
    tw:Play()
    return tw
end

--------------------------------------------------
-- createSlider function
--------------------------------------------------
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

--------------------------------------------------
-- Tween helper (for smooth transitions)
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.25,
		easingStyle or Enum.EasingStyle.Exponential,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

--------------------------------------------------
-- Create a smooth, clean slider control
--------------------------------------------------
local function createSlider(parent, opts, callback)
	opts = opts or {}
	local min = opts.Min or 0
	local max = opts.Max or 100
	local defaultValue = opts.Default or 50
	local sliderLabel = opts.Label or "Slider"
	local initPercent = (defaultValue - min) / (max - min)
	
	-- Outer container (slider) – now a bit smaller (height 100 instead of 130)
	local slider = Instance.new("Frame")
	slider.Name = "Slider"
	slider.Size = opts.Size or UDim2.new(0, 300, 0, 100)
	slider.BackgroundTransparency = 1
	slider.ClipsDescendants = true
	slider.ZIndex = 10
	slider.Parent = parent

	-- UIScale for a subtle pop on hover
	local scaleObj = Instance.new("UIScale", slider)
	scaleObj.Scale = 1

	-- UIStroke for the animated border
	local containerStroke = Instance.new("UIStroke", slider)
	containerStroke.Color = Color3.fromRGB(100, 100, 100)
	containerStroke.Thickness = 2
	containerStroke.Transparency = 0.3

	-- (Removed the Shine overlay entirely for a cleaner look.)

	-----------------------------------
	-- Content Container (holds all UI elements)
	-----------------------------------
	local content = Instance.new("Frame")
	content.Name = "Content"
	content.Size = UDim2.new(1, 0, 1, 0)
	content.Position = UDim2.new(0, 0, 0, 0)
	content.BackgroundTransparency = 1
	-- Place content above the border effects.
	content.ZIndex = slider.ZIndex + 1
	content.Parent = slider

	local padding = Instance.new("UIPadding", content)
	padding.PaddingLeft = UDim.new(0, 8)
	padding.PaddingRight = UDim.new(0, 8)
	padding.PaddingTop = UDim.new(0, 8)
	padding.PaddingBottom = UDim.new(0, 8)

	local layout = Instance.new("UIListLayout", content)
	layout.FillDirection = Enum.FillDirection.Vertical
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 5)

	-- Title Label
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Size = UDim2.new(1, 0, 0, 35)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = sliderLabel
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 26
	titleLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextStrokeTransparency = 0.8
	titleLabel.ZIndex = content.ZIndex
	titleLabel.Parent = content

	-- Value Label
	local valueLabel = Instance.new("TextLabel")
	valueLabel.Name = "ValueLabel"
	valueLabel.Size = UDim2.new(1, 0, 0, 25)
	valueLabel.BackgroundTransparency = 1
	valueLabel.Text = tostring(defaultValue)
	valueLabel.Font = Enum.Font.GothamSemibold
	valueLabel.TextSize = 22
	valueLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
	valueLabel.TextXAlignment = Enum.TextXAlignment.Left
	valueLabel.TextStrokeTransparency = 0.8
	valueLabel.ZIndex = content.ZIndex
	valueLabel.Parent = content

	-- Track (slider bar)
	local track = Instance.new("Frame")
	track.Name = "Track"
	track.Size = UDim2.new(1, -20, 0, 12)  -- inset 10px each side
	track.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
	track.BorderSizePixel = 0
	track.ZIndex = content.ZIndex
	track.Parent = content
	local trackCorner = Instance.new("UICorner", track)
	trackCorner.CornerRadius = UDim.new(0, 6)
	local trackGradient = Instance.new("UIGradient", track)
	trackGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 80, 80)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 60, 60))
	})
	trackGradient.Rotation = 90

	-- Fill inside the track (indicates current value)
	local fill = Instance.new("Frame")
	fill.Name = "Fill"
	fill.Size = UDim2.new(initPercent, 0, 1, 0)
	fill.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
	fill.BorderSizePixel = 0
	fill.ZIndex = track.ZIndex + 1
	fill.Parent = track
	local fillCorner = Instance.new("UICorner", fill)
	fillCorner.CornerRadius = UDim.new(0, 6)
	local fillGradient = Instance.new("UIGradient", fill)
	fillGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 180, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 120, 255))
	})
	fillGradient.Rotation = 90

	-- Draggable Handle
	local handle = Instance.new("TextButton")
	handle.Name = "Handle"
	handle.Size = UDim2.new(0, 20, 0, 20)
	handle.AnchorPoint = Vector2.new(0.5, 0.5)
	handle.Position = UDim2.new(initPercent, 0, 0.5, 0)
	handle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	handle.BorderSizePixel = 0
	handle.AutoButtonColor = false
	handle.Text = ""
	handle.ZIndex = track.ZIndex + 2
	handle.Parent = track
	local handleCorner = Instance.new("UICorner", handle)
	handleCorner.CornerRadius = UDim.new(1, 0)
	local handleStroke = Instance.new("UIStroke", handle)
	handleStroke.Color = Color3.fromRGB(0, 150, 255)
	handleStroke.Thickness = 2
	handleStroke.Transparency = 0.5

	-----------------------------------
	-- Smooth interpolation for fill & handle
	-----------------------------------
	local targetPercent = initPercent
	local currentPercent = initPercent
	local renderConn = RunService.RenderStepped:Connect(function()
		if slider and slider.Parent then
			currentPercent = currentPercent + (targetPercent - currentPercent) * 0.6
			fill.Size = UDim2.new(currentPercent, 0, 1, 0)
			handle.Position = UDim2.new(currentPercent, 0, 0.5, 0)
		else
			renderConn:Disconnect()
		end
	end)

	-----------------------------------
	-- Dragging logic and updating value
	-----------------------------------
	local dragging = false
	local function updateValueFromInput(input)
		local absX = track.AbsolutePosition.X
		local width = track.AbsoluteSize.X
		local mouseX = input.Position.X
		local pos = math.clamp(mouseX - absX, 0, width)
		local percent = pos / width
		targetPercent = percent
		local value = math.floor(min + (max - min) * percent)
		valueLabel.Text = tostring(value)
		if callback then
			callback(value)
		end
	end

	handle.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			tween(handle, {Size = UDim2.new(0, 26, 0, 26)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		end
	end)

	handle.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = false
			tween(handle, {Size = UDim2.new(0, 20, 0, 20)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		end
	end)

	track.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			updateValueFromInput(input)
			tween(handle, {Size = UDim2.new(0, 26, 0, 26)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, function()
				if not dragging then
					tween(handle, {Size = UDim2.new(0, 20, 0, 20)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
				end
			end)
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
			updateValueFromInput(input)
		end
	end)

	-----------------------------------
	-- Container Hover Animation (professional and subtle)
	-----------------------------------
	-- On MouseEnter, smoothly change the border (thicker and blue) and scale up a bit.
	slider.Active = true
	slider.MouseEnter:Connect(function()
		tween(containerStroke, {Thickness = 3, Color = Color3.fromRGB(0, 150, 255), Transparency = 0}, 0.25)
		tween(scaleObj, {Scale = 1.02}, 0.25)
	end)
	slider.MouseLeave:Connect(function()
		tween(containerStroke, {Thickness = 2, Color = Color3.fromRGB(100, 100, 100), Transparency = 0.3}, 0.25)
		tween(scaleObj, {Scale = 1}, 0.25)
	end)

	return slider
end


local TweenService = game:GetService("TweenService")

--------------------------------------------------
-- Helper tween function using exponential easing.
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
    local info = TweenInfo.new(
        duration or 0.3,
        easingStyle or Enum.EasingStyle.Exponential,
        easingDirection or Enum.EasingDirection.Out,
        0,
        false,
        delay or 0
    )
    local tw = TweenService:Create(object, info, properties)
    if callback then
        tw.Completed:Connect(callback)
    end
    tw:Play()
    return tw
end

--------------------------------------------------
-- Redesigned Toggle Function with Animated Border
--------------------------------------------------
local TweenService = game:GetService("TweenService")

--------------------------------------------------
-- Tween helper (for smooth transitions)
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.25,
		easingStyle or Enum.EasingStyle.Exponential,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

--------------------------------------------------
-- Create a smooth, clean toggle control
--------------------------------------------------
local function createToggle(parent, opts, callback)
	opts = opts or {}
	local labelText = opts.Label or "Toggle"
	local defaultState = opts.Default or false

	-- Container: Use a UIListLayout to align the text and toggle track horizontally.
	local container = Instance.new("Frame")
	container.Name = "ToggleContainer"
	container.Size = opts.Size or UDim2.new(1, 0, 0, 40)
	container.BackgroundTransparency = 1
	container.Parent = parent

	local layout = Instance.new("UIListLayout", container)
	layout.FillDirection = Enum.FillDirection.Horizontal
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	layout.VerticalAlignment = Enum.VerticalAlignment.Center
	layout.Padding = UDim.new(0, 10)

	-- Label (left side) with improved styling.
	local label = Instance.new("TextLabel")
	label.Name = "ToggleLabel"
	label.BackgroundTransparency = 1
	label.Text = labelText
	label.Font = opts.Font or Enum.Font.GothamBold
	label.TextSize = opts.TextSize or 20
	label.TextColor3 = opts.TextColor or Color3.fromRGB(240, 240, 240)
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.AutomaticSize = Enum.AutomaticSize.X
	-- Optional text stroke for better clarity.
	label.TextStrokeColor3 = opts.TextStrokeColor or Color3.new(0, 0, 0)
	label.TextStrokeTransparency = opts.TextStrokeTransparency or 0.8
	label.Parent = container

	-- Toggle track (right side)
	local track = Instance.new("Frame")
	track.Name = "ToggleTrack"
	track.Size = UDim2.new(0, 60, 0, 30)
	track.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	track.BorderSizePixel = 0
	track.Parent = container

	-- Rounded corners on the track
	local trackCorner = Instance.new("UICorner", track)
	trackCorner.CornerRadius = UDim.new(0, 15)

	-- Subtle gradient on the track for depth.
	local trackGradient = Instance.new("UIGradient", track)
	trackGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(40, 40, 40)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 60, 60))
	})
	trackGradient.Rotation = 90

	-- Animated border (stroke) around the track.
	local borderStroke = Instance.new("UIStroke", track)
	borderStroke.Color = Color3.fromRGB(100, 100, 100)
	borderStroke.Thickness = 2
	borderStroke.Transparency = 0.5

	-- Add a UIScale to the track to allow a subtle scale animation on hover.
	local trackScale = Instance.new("UIScale", track)
	trackScale.Scale = 1

	-- Glow frame for extra visual flair when toggled on.
	local glow = Instance.new("Frame")
	glow.Name = "ToggleGlow"
	glow.Size = UDim2.new(1, 6, 1, 6)
	glow.Position = UDim2.new(0, -3, 0, -3)
	glow.BackgroundColor3 = Color3.fromRGB(0, 180, 255)
	glow.BackgroundTransparency = 1  -- starts hidden
	glow.Parent = track
	local glowCorner = Instance.new("UICorner", glow)
	glowCorner.CornerRadius = UDim.new(0, 15)

	-- Toggle handle (the sliding indicator)
	local handle = Instance.new("Frame")
	handle.Name = "ToggleHandle"
	handle.Size = UDim2.new(0, 26, 0, 26)
	-- Set the handle color depending on state.
	handle.BackgroundColor3 = defaultState and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(200, 200, 200)
	handle.BorderSizePixel = 0
	handle.Parent = track
	local handleCorner = Instance.new("UICorner", handle)
	handleCorner.CornerRadius = UDim.new(1, 0)

	-- Define positions for off and on states.
	local offPosition = UDim2.new(0, 2, 0.5, -13)
	local onPosition  = UDim2.new(1, -28, 0.5, -13)
	handle.Position = defaultState and onPosition or offPosition

	-- Optional: Add a subtle shadow for the handle.
	local shadow = Instance.new("ImageLabel")
	shadow.Name = "HandleShadow"
	shadow.Size = handle.Size
	shadow.Position = UDim2.new(0, 2, 0, 2)
	shadow.BackgroundTransparency = 1
	shadow.Image = "rbxassetid://131604521"  -- Replace with your asset if desired
	shadow.ImageColor3 = Color3.new(0, 0, 0)
	shadow.ImageTransparency = 0.5
	shadow.Parent = handle
	shadow.ZIndex = handle.ZIndex - 1

	-- Current state of the toggle.
	local state = defaultState

	--------------------------------------------------
	-- Function to update the toggle state.
	--------------------------------------------------
	local function updateToggle(newState)
		state = newState
		if state then
			tween(handle, {Position = onPosition}, 0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			tween(track, {BackgroundColor3 = Color3.fromRGB(0, 180, 255)}, 0.25)
			tween(handle, {BackgroundColor3 = Color3.fromRGB(255, 255, 255)}, 0.25)
			tween(glow, {BackgroundTransparency = 0.4}, 0.25)
			tween(borderStroke, {Color = Color3.fromRGB(0, 180, 255), Thickness = 4, Transparency = 0}, 0.25)
		else
			tween(handle, {Position = offPosition}, 0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			tween(track, {BackgroundColor3 = Color3.fromRGB(50, 50, 50)}, 0.25)
			tween(handle, {BackgroundColor3 = Color3.fromRGB(200, 200, 200)}, 0.25)
			tween(glow, {BackgroundTransparency = 1}, 0.25)
			tween(borderStroke, {Color = Color3.fromRGB(100, 100, 100), Thickness = 2, Transparency = 0.5}, 0.25)
		end
		if callback then
			callback(state)
		end
	end

	--------------------------------------------------
	-- Connect mouse input: Toggle when the track is clicked.
	--------------------------------------------------
	track.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			updateToggle(not state)
		end
	end)

	--------------------------------------------------
	-- Hover animations for the toggle track (a subtle, professional effect)
	--------------------------------------------------
	track.MouseEnter:Connect(function()
		tween(trackScale, {Scale = 1.03}, 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		-- Adjust the border slightly on hover.
		if state then
			tween(borderStroke, {Thickness = 4.5, Transparency = 0}, 0.15)
		else
			tween(borderStroke, {Thickness = 2.5, Transparency = 0.4}, 0.15)
		end
	end)
	track.MouseLeave:Connect(function()
		tween(trackScale, {Scale = 1}, 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		-- Return the border to its normal settings.
		if state then
			tween(borderStroke, {Thickness = 4, Transparency = 0}, 0.15)
		else
			tween(borderStroke, {Thickness = 2, Transparency = 0.5}, 0.15)
		end
	end)

	return container
end


local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Utility tween function for smooth transitions
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.15,
		easingStyle or Enum.EasingStyle.Sine,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

-- Create a button with a smooth, professional click animation.
local function createButton(parent, opts, callback)
	opts = opts or {}

	-- Main Button Setup
	local button = Instance.new("TextButton")
	button.Name = opts.Name or "CoolButton"
	button.Size = opts.Size or UDim2.new(0, 150, 0, 50)
	button.Position = opts.Position or UDim2.new(0, 0, 0, 0)
	button.BackgroundColor3 = opts.BackgroundColor or Color3.fromRGB(0, 150, 255)
	button.Text = opts.Text or "Button"
	button.Font = opts.Font or Enum.Font.GothamBold
	button.TextSize = opts.TextSize or 18
	button.TextColor3 = opts.TextColor or Color3.fromRGB(240, 240, 240)
	button.AutoButtonColor = false
	button.Parent = parent

	-- Optional drop shadow for extra depth
	if opts.DropShadow then
		local shadow = Instance.new("Frame")
		shadow.Name = "DropShadow"
		shadow.Size = button.Size
		shadow.Position = UDim2.new(0, opts.ShadowOffsetX or 3, 0, opts.ShadowOffsetY or 3)
		shadow.BackgroundColor3 = opts.ShadowColor or Color3.new(0, 0, 0)
		shadow.BackgroundTransparency = opts.ShadowTransparency or 0.5
		shadow.ZIndex = button.ZIndex - 1
		shadow.Parent = button

		local shadowCorner = Instance.new("UICorner")
		shadowCorner.CornerRadius = opts.CornerRadius or UDim.new(0, 12)
		shadowCorner.Parent = shadow
	end

	-- Rounded corners for a modern look
	local corner = Instance.new("UICorner")
	corner.CornerRadius = opts.CornerRadius or UDim.new(0, 12)
	corner.Parent = button

	-- Subtle outline (stroke)
	local stroke = Instance.new("UIStroke")
	stroke.Thickness = opts.StrokeThickness or 2
	stroke.Color = opts.StrokeColor or Color3.fromRGB(0, 120, 200)
	stroke.Transparency = opts.StrokeTransparency or 0.4
	stroke.Parent = button

	-- Dynamic gradient background
	local gradient = Instance.new("UIGradient")
	gradient.Color = opts.GradientColor or ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 170, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 130, 255))
	})
	gradient.Rotation = opts.GradientRotation or 90
	gradient.Parent = button

	-- UIScale to allow subtle scale animations
	local scale = Instance.new("UIScale")
	scale.Scale = 1
	scale.Parent = button

	--------------------------------------
	-- Hover Effects (color, stroke & gradient)
	--------------------------------------
	button.MouseEnter:Connect(function()
		tween(button, { BackgroundColor3 = opts.HoverColor or Color3.fromRGB(0, 180, 255) }, 0.15)
		tween(stroke, { Transparency = opts.StrokeHoverTransparency or 0.2 }, 0.15)
		tween(gradient, { Rotation = opts.GradientHoverRotation or 0 }, 0.15)
	end)

	button.MouseLeave:Connect(function()
		tween(button, { BackgroundColor3 = opts.BackgroundColor or Color3.fromRGB(0, 150, 255) }, 0.15)
		tween(stroke, { Transparency = opts.StrokeTransparency or 0.4 }, 0.15)
		tween(gradient, { Rotation = opts.GradientRotation or 90 }, 0.15)
	end)

	--------------------------------------
	-- Refined Click Animation (No Ripple)
	--------------------------------------
	-- On press, slightly scale down and darken the button.
	button.MouseButton1Down:Connect(function()
		tween(scale, { Scale = opts.PressScale or 0.98 }, 0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		-- Slight darkening on press; change color to a subtle darker hue.
		local clickColor = opts.ClickColor or Color3.fromRGB(0, 140, 240)
		tween(button, { BackgroundColor3 = clickColor }, 0.08)
	end)

	-- On release, scale back to full size and revert background color.
	button.MouseButton1Up:Connect(function()
		tween(scale, { Scale = 1 }, 0.12, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		tween(button, { BackgroundColor3 = opts.BackgroundColor or Color3.fromRGB(0, 150, 255) }, 0.12)
		if callback then
			callback()
		end
	end)

	return button
end

---------------------------
-- Base UI Window & Tab System with Sections
---------------------------
-- If an older version exists, remove it.
if game.CoreGui:FindFirstChild("CometUI") then
    game.CoreGui:FindFirstChild("CometUI"):Destroy()
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CometUI"
screenGui.Parent = game.CoreGui
screenGui.IgnoreGuiInset = true

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Parent = screenGui
mainFrame.Size = UDim2.new(0,500,0,400)
mainFrame.Position = UDim2.new(0.5,0,0.5,0)
mainFrame.AnchorPoint = Vector2.new(0.5,0.5)
mainFrame.BackgroundColor3 = Color3.fromRGB(35,35,35)
mainFrame.BorderSizePixel = 0
local mainCorner = Instance.new("UICorner", mainFrame)
mainCorner.CornerRadius = UDim.new(0,12)
local mainGradient = Instance.new("UIGradient", mainFrame)
mainGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(45,45,45)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(35,35,35))
}

local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Parent = mainFrame
titleBar.Size = UDim2.new(1,0,0,30)
titleBar.BackgroundColor3 = Color3.fromRGB(30,30,30)
titleBar.BorderSizePixel = 0
local titleBarCorner = Instance.new("UICorner", titleBar)
titleBarCorner.CornerRadius = UDim.new(0,12)

local titleText = Instance.new("TextLabel")
titleText.Name = "TitleText"
titleText.Parent = titleBar
titleText.Size = UDim2.new(1,0,1,0)
titleText.BackgroundTransparency = 1
titleText.Text = "CometWare"
titleText.TextColor3 = Color3.fromRGB(240,240,240)
titleText.Font = Enum.Font.GothamBold
titleText.TextSize = 20
titleText.TextStrokeTransparency = 0.85
titleText.Position = UDim2.new(0.02,0,0,0)

local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Parent = titleBar
closeButton.Size = UDim2.new(0,30,0,30)
closeButton.Position = UDim2.new(1,-30,0,0)
closeButton.BackgroundColor3 = Color3.fromRGB(200,80,80)
closeButton.Text = "X"
closeButton.TextColor3 = Color3.fromRGB(240,240,240)
closeButton.Font = Enum.Font.GothamBold
closeButton.TextSize = 16
local closeCorner = Instance.new("UICorner", closeButton)
closeCorner.CornerRadius = UDim.new(0,5)
closeButton.MouseButton1Click:Connect(function()
    tween(mainFrame, {BackgroundTransparency = 1}, 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, function()
        screenGui:Destroy()
    end)
end)

-- Draggability using the title bar.
local dragging = false
local dragInput, dragStart, startPos
titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then dragging = false end
        end)
    end
end)
titleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then dragInput = input end
end)
UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        local delta = input.Position - dragStart
        mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

-- Tab System Containers.
local tabButtonsFrame = Instance.new("Frame")
tabButtonsFrame.Name = "TabButtonsFrame"
tabButtonsFrame.Parent = mainFrame
tabButtonsFrame.Size = UDim2.new(1,0,0,40)
tabButtonsFrame.Position = UDim2.new(0,0,0,30)
tabButtonsFrame.BackgroundTransparency = 1

local tabContentFrame = Instance.new("Frame")
tabContentFrame.Name = "TabContentFrame"
tabContentFrame.Parent = mainFrame
tabContentFrame.Size = UDim2.new(1,0,1,-70)
tabContentFrame.Position = UDim2.new(0,0,0,70)
tabContentFrame.BackgroundTransparency = 1

---------------------------
-- Build the base window API.
---------------------------
local windowAPI = {}
windowAPI.TabButtonsFrame = tabButtonsFrame
windowAPI.TabContentFrame = tabContentFrame
windowAPI.Tabs = {}
windowAPI.ActiveTab = nil


local TweenService = game:GetService("TweenService")

--------------------------------------------------
-- Tween helper (for smooth, crisp animations)
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.25,
		easingStyle or Enum.EasingStyle.Quad,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

--------------------------------------------------
-- Create a new tab for the window
--------------------------------------------------
local function createTab(windowAPI, tabName)
	local tab = {}
	tab.Name = tabName
	tab.Sections = {}

	---------------------------------------------------
	-- Ensure the TabButtonsFrame has a horizontal layout
	---------------------------------------------------
	local tabButtonsFrame = windowAPI.TabButtonsFrame
	if not tabButtonsFrame:FindFirstChildOfClass("UIListLayout") then
		local listLayout = Instance.new("UIListLayout")
		listLayout.FillDirection = Enum.FillDirection.Horizontal
		listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
		listLayout.VerticalAlignment = Enum.VerticalAlignment.Center
		listLayout.Padding = UDim.new(0, 5)
		listLayout.Parent = tabButtonsFrame
	end

	-----------------------------
	-- Create the tab button:
	-----------------------------
	local tabButton = Instance.new("TextButton")
	tabButton.Name = "TabButton"
	tabButton.Text = tabName
	tabButton.Size = UDim2.new(0, 120, 1, 0) -- a bit wider for a cleaner look

	-- Use a cool blue–gray color that pops on a black background.
	tabButton.BackgroundColor3 = Color3.fromRGB(80, 80, 120)
	tabButton.TextColor3 = Color3.new(1, 1, 1)
	tabButton.Font = Enum.Font.GothamBold
	tabButton.TextSize = 16
	tabButton.AutoButtonColor = false
	tabButton.Parent = tabButtonsFrame

	-- Add a subtle UIGradient for depth.
	local buttonGradient = Instance.new("UIGradient")
	buttonGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 80, 120)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(70, 70, 110))
	})
	buttonGradient.Rotation = 90
	buttonGradient.Parent = tabButton

	-- Add smooth rounded corners.
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = tabButton

	-- Add an active indicator (a thin line at the bottom).
	local indicator = Instance.new("Frame")
	indicator.Name = "ActiveIndicator"
	indicator.Size = UDim2.new(1, 0, 0, 3)
	indicator.Position = UDim2.new(0, 0, 1, -3)
	indicator.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
	indicator.BackgroundTransparency = 1  -- hidden by default
	indicator.Parent = tabButton

	-- Add a subtle UIScale for hover animations.
	local scaleObj = Instance.new("UIScale")
	scaleObj.Scale = 1
	scaleObj.Parent = tabButton

	-----------------------------
	-- Add Hover & Active Effects:
	-----------------------------
	tabButton.MouseEnter:Connect(function()
		-- Only animate if this tab isn't active.
		if windowAPI.ActiveTab ~= tab then
			tween(scaleObj, { Scale = 1.05 }, 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			tween(tabButton, { BackgroundColor3 = Color3.fromRGB(100, 100, 160) }, 0.15)
		end
	end)

	tabButton.MouseLeave:Connect(function()
		if windowAPI.ActiveTab ~= tab then
			tween(scaleObj, { Scale = 1 }, 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			tween(tabButton, { BackgroundColor3 = Color3.fromRGB(80, 80, 120) }, 0.15)
		end
	end)

-- When a tab is clicked, animate its active state, hide other tabs’ content,
-- and mark this one as active.
tabButton.MouseButton1Click:Connect(function()
    -- Reset all tabs.
    for _, t in pairs(windowAPI.Tabs) do
        if t.Button then
            tween(t.Button, { BackgroundColor3 = Color3.fromRGB(80, 80, 120) }, 0.15)
            local ind = t.Button:FindFirstChild("ActiveIndicator")
            if ind then
                tween(ind, { BackgroundTransparency = 1 }, 0.15)
            end
            -- Reset scale.
            local s = t.Button:FindFirstChildOfClass("UIScale")
            if s then
                tween(s, { Scale = 1 }, 0.15)
            end
        end
        if t.Content then
            t.Content.Visible = false
        end
    end

    -- Activate this tab.
    tween(tabButton, { BackgroundColor3 = Color3.fromRGB(110, 110, 180) }, 0.15)
    if tabButton:FindFirstChild("ActiveIndicator") then
        tween(tabButton.ActiveIndicator, { BackgroundTransparency = 0 }, 0.15)
    end

    -- Use the stored tab content.
    tab.Content.Visible = true
    windowAPI.ActiveTab = tab
end)


	-- If no active tab exists yet, initialize with this one.
	local initActive = not windowAPI.ActiveTab
	if initActive then
		windowAPI.ActiveTab = tab
		tabContentVisible = true
		tween(tabButton, { BackgroundColor3 = Color3.fromRGB(110, 110, 180) }, 0.15)
		if tabButton:FindFirstChild("ActiveIndicator") then
			tween(tabButton.ActiveIndicator, { BackgroundTransparency = 0 }, 0.15)
		end
	else
		tabContentVisible = false
	end

	-----------------------------
	-- Create the tab content:
	-----------------------------
	local tabContent = Instance.new("ScrollingFrame")
	tabContent.Name = "TabContent_" .. tabName
	tabContent.Size = UDim2.new(1, -10, 1, -10)
	tabContent.Position = UDim2.new(0, 5, 0, 5)
	tabContent.BackgroundTransparency = 1
	tabContent.ScrollBarThickness = 4
	tabContent.Visible = initActive
	tabContent.Parent = windowAPI.TabContentFrame

	-- Add a vertical layout to organize content.
	local listLayout = Instance.new("UIListLayout", tabContent)
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 5)

	-- Save references for later use.
	tab.Button = tabButton
	tab.Content = tabContent

	-----------------------------
	-- Allow adding sections:
	-----------------------------
	function tab:AddSection(sectionName)
		local section = {}
		section.Name = sectionName

		local sectionFrame = Instance.new("Frame")
		sectionFrame.Name = "Section_" .. sectionName
		sectionFrame.Size = UDim2.new(1, 0, 0, 100)  -- default height; adjust as needed
		sectionFrame.BackgroundTransparency = 1
		sectionFrame.Parent = tabContent

		-- Use a layout to neatly stack elements.
		local sectionLayout = Instance.new("UIListLayout", sectionFrame)
		sectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
		sectionLayout.Padding = UDim.new(0, 5)

		section.Frame = sectionFrame

		-- These functions assume you have createSlider, createToggle, and createButton defined.
		function section:AddSlider(opts, callback)
			createSlider(sectionFrame, opts, callback)
		end
		function section:AddToggle(opts, callback)
			createToggle(sectionFrame, opts, callback)
		end
		function section:AddButton(opts, callback)
			createButton(sectionFrame, opts, callback)
		end

		table.insert(tab.Sections, section)
		return section
	end

	table.insert(windowAPI.Tabs, tab)
	return tab
end

--------------------------------------------------
-- Add a new tab via your windowAPI.
--------------------------------------------------
function windowAPI:AddTab(tabName)
	return createTab(self, tabName)
end

---------------------------
-- UI Visibility Toggle (RightShift)
---------------------------
local uiVisible = true
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.RightShift then
        uiVisible = not uiVisible
        local mainFrameRef = game.CoreGui:FindFirstChild("CometUI") and game.CoreGui.CometUI:FindFirstChild("MainFrame")
        if mainFrameRef then
            if uiVisible then
                mainFrameRef.Visible = true
                tween(mainFrameRef, {BackgroundTransparency = 0}, 0.3, Enum.EasingStyle.Sine)
            else
                tween(mainFrameRef, {BackgroundTransparency = 1}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, function()
                    mainFrameRef.Visible = false
                end)
            end
        end
    end
end)

---------------------------
-- Expose the Base Window API Globally via a CometUI module
---------------------------
local CometUI = {}
function CometUI:CreateWindow(config)
    if config then
        if config.Title then
            titleText.Text = config.Title
        end
        if config.Size then
            mainFrame.Size = config.Size
            mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
        end
    end
    return windowAPI
end

_G.baseWindow = CometUI:CreateWindow({ Title = "CometWare", Size = UDim2.new(0,500,0,400) })
print("Base UI created. Use _G.baseWindow:AddTab('Tab Name') to add a new tab.")

-- Add a new tab named "Player"
local playerTab = _G.baseWindow:AddTab("CometWare")

-- Add a section to the "Player" tab
local speedSection = playerTab:AddSection("Speed Settings")

speedSection:AddSlider({
    Label = "Walk Speed",
    Min = 16,
    Max = 100,
    Default = 16,
    Size = UDim2.new(0, 300, 0, 140)
}, function(value)
    print("Walk Speed changed to:", value)
    -- Update the player's WalkSpeed here.
end)

-- Add a highly animated slider
speedSection:AddToggle({
    Label = "toggle",
    Default = false,
    Size = UDim2.new(0, 300, 0, 40)
}, function(state)
    print("toggle:", state)
    -- Toggle god mode here
end)


-- Add an animated button with a ripple effect
speedSection:AddButton({
    Text = "button",
    Size = UDim2.new(0, 300, 0, 50)
}, function()
    print("Reset button clicked!")
    -- Reset functionality here
end)


-- Add a new tab named "Player"
local testTab = _G.baseWindow:AddTab("2")

-- Add a section to the "Player" tab
local testSection = testTab:AddSection("section")

testSection:AddButton({
    Text = "button",
    Size = UDim2.new(0, 300, 0, 50)
}, function()
    print("button clicked!")
    -- functionality here
end)
