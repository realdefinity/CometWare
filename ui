local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

local loadingGui = Instance.new("ScreenGui")
loadingGui.Name = "CometLoadingGui"
loadingGui.Parent = game.CoreGui
loadingGui.IgnoreGuiInset = true

local bg = Instance.new("Frame")
bg.Name = "Background"
bg.Parent = loadingGui
bg.Size = UDim2.new(1, 0, 1, 0)
bg.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
bg.BackgroundTransparency = 0.3
local bgGradient = Instance.new("UIGradient", bg)
bgGradient.Rotation = 90
bgGradient.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.fromRGB(40,40,40)), ColorSequenceKeypoint.new(1, Color3.fromRGB(60,60,60))})

local loadingFrame = Instance.new("Frame")
loadingFrame.Name = "LoadingFrame"
loadingFrame.Parent = loadingGui
loadingFrame.Size = UDim2.new(0, 400, 0, 150)
loadingFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
loadingFrame.AnchorPoint = Vector2.new(0.5, 0.5)
loadingFrame.BackgroundTransparency = 1

local cometLabel = Instance.new("TextLabel")
cometLabel.Name = "CometLabel"
cometLabel.Parent = loadingFrame
cometLabel.Size = UDim2.new(1, 0, 1, 0)
cometLabel.BackgroundTransparency = 1
cometLabel.Text = "Comet"
cometLabel.Font = Enum.Font.GothamSemibold
cometLabel.TextSize = 72
cometLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
cometLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
cometLabel.TextStrokeTransparency = 0.5
cometLabel.TextTransparency = 0
cometLabel.ZIndex = 2

spawn(function()
	while cometLabel and cometLabel.Parent do
		local pulseUp = TweenService:Create(cometLabel, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextSize = 80})
		pulseUp:Play()
		pulseUp.Completed:Wait()
		local pulseDown = TweenService:Create(cometLabel, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextSize = 72})
		pulseDown:Play()
		pulseDown.Completed:Wait()
	end
end)

local function spawnComet()
	local comet = Instance.new("ImageLabel")
	comet.Name = "FlyingComet"
	comet.Size = UDim2.new(0, 40, 0, 20)
	comet.BackgroundTransparency = 1
	comet.Image = "rbxassetid://YOUR_ASSET_ID"
	comet.ImageColor3 = Color3.fromRGB(200, 200, 200)
	comet.ImageTransparency = 0
	comet.Parent = loadingFrame
	comet.ZIndex = 1
	local startX = -50
	local endX = 450
	local yPos = 75 + math.random(-10,10)
	comet.Position = UDim2.new(0, startX, 0, yPos)
	local cometTween = TweenService:Create(comet, TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(0, endX, 0, yPos), ImageTransparency = 1})
	cometTween:Play()
	
	local trail = Instance.new("ImageLabel")
	trail.Name = "CometTrail"
	trail.Size = UDim2.new(0, 50, 0, 25)
	trail.BackgroundTransparency = 1
	trail.Image = comet.Image
	trail.ImageColor3 = Color3.fromRGB(200,200,200)
	trail.ImageTransparency = 0.2
	trail.Parent = loadingFrame
	trail.ZIndex = comet.ZIndex - 1
	trail.Position = UDim2.new(0, startX - 10, 0, yPos)
	TweenService:Create(trail, TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(0, endX - 10, 0, yPos), ImageTransparency = 1}):Play()
	delay(0.8, function() trail:Destroy() end)
	delay(0.8, function() comet:Destroy() end)
end

spawn(function()
	for i = 1, 3 do
		spawnComet()
		wait(1)
	end
end)

spawn(function()
	while bgGradient do
		TweenService:Create(bgGradient, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Offset = Vector2.new(math.random(-50,50), math.random(-50,50))}):Play()
		wait(2)
	end
end)

wait(3)

local fadeTween = TweenService:Create(loadingFrame, TweenInfo.new(0.75, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 1})
fadeTween:Play()
local fadeBgTween = TweenService:Create(bg, TweenInfo.new(0.75, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 1})
fadeBgTween:Play()
fadeBgTween.Completed:Wait()

StarterGui:SetCore("SendNotification", {Title = "Comet Loaded.", Text = "Thanks for using comet!", Duration = 5})
loadingGui:Destroy()

---------------------------
-- SERVICES & UTILITY FUNCTIONS
---------------------------
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Modified tween function now supports an optional callback
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
    local info = TweenInfo.new(
        duration or 0.2,
        easingStyle or Enum.EasingStyle.Sine,
        easingDirection or Enum.EasingDirection.Out,
        0,
        false,
        delay or 0
    )
    local tw = TweenService:Create(object, info, properties)
    if callback then
        tw.Completed:Connect(callback)
    end
    tw:Play()
    return tw
end

---------------------------
-- UI ELEMENT FUNCTIONS
---------------------------


local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

--------------------------------------------------
-- Helper Tween Function
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.25,
		easingStyle or Enum.EasingStyle.Quad,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

--------------------------------------------------
-- createSlider Function (Polished Version)
--------------------------------------------------
local function createSlider(parent, opts, callback)
	opts = opts or {}
	local min = opts.Min or 0
	local max = opts.Max or 100
	local defaultValue = opts.Default or 50
	local sliderLabel = opts.Label or "Slider"
	local initPercent = (defaultValue - min) / (max - min)
	
	-- If the slider is meant to be closely grouped, reduce height slightly.
	local sliderHeight = opts.Organization and 80 or 100
	
	-- Outer Container (Slider)
	local slider = Instance.new("Frame")
	slider.Name = "Slider"
	slider.Size = opts.Size or UDim2.new(0, 320, 0, sliderHeight)
	slider.BackgroundColor3 = Color3.fromRGB(30, 30, 30)  -- dark background for contrast
	slider.BackgroundTransparency = 0
	slider.ClipsDescendants = true
	slider.ZIndex = 10
	slider.Parent = parent

	-- Drop Shadow Effect (for container depth)
	local shadow = Instance.new("Frame")
	shadow.Name = "Shadow"
	shadow.Size = slider.Size
	shadow.Position = UDim2.new(0, 4, 0, 4)
	shadow.BackgroundColor3 = Color3.new(0, 0, 0)
	shadow.BackgroundTransparency = 0.5
	shadow.BorderSizePixel = 0
	shadow.ZIndex = slider.ZIndex - 1
	shadow.Parent = slider

	-- UIStroke (Container Border)
	local containerStroke = Instance.new("UIStroke")
	containerStroke.Parent = slider
	containerStroke.Thickness = 2
	containerStroke.Color = Color3.fromRGB(100, 100, 100)
	containerStroke.Transparency = 0.2

	-- Rounded Corners for container
	local containerCorner = Instance.new("UICorner", slider)
	containerCorner.CornerRadius = UDim.new(0, 10)

	-- UIScale for subtle hover effect
	local scaleObj = Instance.new("UIScale", slider)
	scaleObj.Scale = 1

	-----------------------------------
	-- Content Container
	-----------------------------------
	local content = Instance.new("Frame")
	content.Name = "Content"
	content.Size = UDim2.new(1, 0, 1, 0)
	content.Position = UDim2.new(0, 0, 0, 0)
	content.BackgroundTransparency = 1
	content.ZIndex = slider.ZIndex + 1
	content.Parent = slider

	-- Padding for content; slightly tighter if Organization is set.
	local padding = Instance.new("UIPadding", content)
	if opts.Organization then
		padding.PaddingLeft = UDim.new(0, 6)
		padding.PaddingRight = UDim.new(0, 6)
		padding.PaddingTop = UDim.new(0, 4)
		padding.PaddingBottom = UDim.new(0, 4)
	else
		padding.PaddingLeft = UDim.new(0, 10)
		padding.PaddingRight = UDim.new(0, 10)
		padding.PaddingTop = UDim.new(0, 10)
		padding.PaddingBottom = UDim.new(0, 10)
	end

	local layout = Instance.new("UIListLayout", content)
	layout.FillDirection = Enum.FillDirection.Vertical
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 4)

	-- Optional Organization Header (for grouping)
	if opts.Organization and opts.OrgLabel then
		local orgLabel = Instance.new("TextLabel")
		orgLabel.Name = "OrganizationLabel"
		orgLabel.Size = UDim2.new(1, 0, 0, 20)
		orgLabel.BackgroundTransparency = 1
		orgLabel.Text = opts.OrgLabel
		orgLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
		orgLabel.Font = Enum.Font.GothamBold
		orgLabel.TextSize = 18
		orgLabel.TextXAlignment = Enum.TextXAlignment.Left
		orgLabel.ZIndex = content.ZIndex
		orgLabel.Parent = content
	end

	-- Title Label
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Size = UDim2.new(1, 0, 0, 35)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = sliderLabel
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 26
	titleLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextStrokeTransparency = 0.8
	titleLabel.ZIndex = content.ZIndex
	titleLabel.Parent = content

	-- Value Label
	local valueLabel = Instance.new("TextLabel")
	valueLabel.Name = "ValueLabel"
	valueLabel.Size = UDim2.new(1, 0, 0, 25)
	valueLabel.BackgroundTransparency = 1
	valueLabel.Text = tostring(defaultValue)
	valueLabel.Font = Enum.Font.GothamSemibold
	valueLabel.TextSize = 22
	valueLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
	valueLabel.TextXAlignment = Enum.TextXAlignment.Left
	valueLabel.TextStrokeTransparency = 0.8
	valueLabel.ZIndex = content.ZIndex
	valueLabel.Parent = content

	-- Track (Slider Bar)
	local track = Instance.new("Frame")
	track.Name = "Track"
	track.Size = UDim2.new(1, -20, 0, 12)
	track.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
	track.BorderSizePixel = 0
	track.ZIndex = content.ZIndex
	track.Parent = content

	local trackCorner = Instance.new("UICorner", track)
	trackCorner.CornerRadius = UDim.new(0, 6)

	local trackGradient = Instance.new("UIGradient", track)
	trackGradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 80, 80)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 60, 60))
	}
	trackGradient.Rotation = 90

	-- Fill inside the Track
	local fill = Instance.new("Frame")
	fill.Name = "Fill"
	fill.Size = UDim2.new(initPercent, 0, 1, 0)
	fill.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
	fill.BorderSizePixel = 0
	fill.ZIndex = track.ZIndex + 1
	fill.Parent = track

	local fillCorner = Instance.new("UICorner", fill)
	fillCorner.CornerRadius = UDim.new(0, 6)

	local fillGradient = Instance.new("UIGradient", fill)
	fillGradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 180, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 120, 255))
	}
	fillGradient.Rotation = 90

	-- Draggable Handle
	local handle = Instance.new("TextButton")
	handle.Name = "Handle"
	handle.Size = UDim2.new(0, 20, 0, 20)
	handle.AnchorPoint = Vector2.new(0.5, 0.5)
	handle.Position = UDim2.new(initPercent, 0, 0.5, 0)
	handle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	handle.BorderSizePixel = 0
	handle.AutoButtonColor = false
	handle.Text = ""
	handle.ZIndex = track.ZIndex + 2
	handle.Parent = track

	local handleCorner = Instance.new("UICorner", handle)
	handleCorner.CornerRadius = UDim.new(1, 0)

	local handleStroke = Instance.new("UIStroke", handle)
	handleStroke.Color = Color3.fromRGB(0, 150, 255)
	handleStroke.Thickness = 2
	handleStroke.Transparency = 0.5

	-----------------------------------
	-- Smooth interpolation for fill & handle
	-----------------------------------
	local targetPercent = initPercent
	local currentPercent = initPercent
	local renderConn = RunService.RenderStepped:Connect(function()
		if slider and slider.Parent then
			currentPercent = currentPercent + (targetPercent - currentPercent) * 0.6
			fill.Size = UDim2.new(currentPercent, 0, 1, 0)
			handle.Position = UDim2.new(currentPercent, 0, 0.5, 0)
		else
			renderConn:Disconnect()
		end
	end)

	-----------------------------------
	-- Dragging logic and updating value
	-----------------------------------
	local dragging = false
	local function updateValueFromInput(input)
		local absX = track.AbsolutePosition.X
		local width = track.AbsoluteSize.X
		local mouseX = input.Position.X
		local pos = math.clamp(mouseX - absX, 0, width)
		local percent = pos / width
		
		-- If snapping is enabled, round the value to the nearest increment.
		if opts.Snap and opts.Increment then
			local rawValue = min + (max - min) * percent
			local snappedValue = math.floor(rawValue / opts.Increment + 0.5) * opts.Increment
			percent = (snappedValue - min) / (max - min)
			valueLabel.Text = tostring(snappedValue)
			targetPercent = percent
			if callback then
				callback(snappedValue)
			end
		else
			targetPercent = percent
			local value = math.floor(min + (max - min) * percent)
			valueLabel.Text = tostring(value)
			if callback then
				callback(value)
			end
		end
	end

	handle.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			tween(handle, {Size = UDim2.new(0, 26, 0, 26)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		end
	end)

	handle.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = false
			tween(handle, {Size = UDim2.new(0, 20, 0, 20)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		end
	end)

	track.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			updateValueFromInput(input)
			tween(handle, {Size = UDim2.new(0, 26, 0, 26)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, function()
				if not dragging then
					tween(handle, {Size = UDim2.new(0, 20, 0, 20)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
				end
			end)
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
			updateValueFromInput(input)
		end
	end)

	return slider
end


local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

--------------------------------------------------
-- Helper Tween Function
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.25,
		easingStyle or Enum.EasingStyle.Quad,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

--------------------------------------------------
-- createToggle Function (Repositioned for Better Layout)
--------------------------------------------------
local function createToggle(parent, opts, callback)
	opts = opts or {}
	local labelText = opts.Label or "Toggle"
	local defaultState = opts.Default or false

	-- Outer Container: Fixed size for proper layout.
	local container = Instance.new("Frame")
	container.Name = "ToggleContainer"
	container.Size = opts.Size or UDim2.new(1, 0, 0, 40)
	container.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	container.BackgroundTransparency = 0
	container.Parent = parent

	-- Drop Shadow for depth.
	local shadow = Instance.new("Frame")
	shadow.Name = "ToggleShadow"
	shadow.Size = container.Size
	shadow.Position = UDim2.new(0, 4, 0, 4)
	shadow.BackgroundColor3 = Color3.new(0, 0, 0)
	shadow.BackgroundTransparency = 0.5
	shadow.BorderSizePixel = 0
	shadow.ZIndex = container.ZIndex - 1
	shadow.Parent = container

	-- Border using UIStroke.
	local containerStroke = Instance.new("UIStroke")
	containerStroke.Parent = container
	containerStroke.Thickness = 2
	containerStroke.Color = Color3.fromRGB(100, 100, 100)
	containerStroke.Transparency = 0.3

	-- Rounded corners for container.
	local containerCorner = Instance.new("UICorner", container)
	containerCorner.CornerRadius = UDim.new(0, 10)

	-- Manually position the label and toggle track.
	-- Label: occupies most of the container on the left.
	local label = Instance.new("TextLabel")
	label.Name = "ToggleLabel"
	label.BackgroundTransparency = 1
	label.Text = labelText
	label.Font = opts.Font or Enum.Font.GothamBold
	label.TextSize = opts.TextSize or 20
	label.TextColor3 = opts.TextColor or Color3.fromRGB(240, 240, 240)
	label.TextXAlignment = Enum.TextXAlignment.Left
	-- Leave space on the right (about 80 pixels) for the toggle track.
	label.Size = UDim2.new(1, -80, 1, 0)
	label.Position = UDim2.new(0, 10, 0, 0)
	label.TextStrokeColor3 = opts.TextStrokeColor or Color3.new(0, 0, 0)
	label.TextStrokeTransparency = opts.TextStrokeTransparency or 0.8
	label.Parent = container

	-- Toggle track: fixed size on the right.
	local track = Instance.new("Frame")
	track.Name = "ToggleTrack"
	track.Size = UDim2.new(0, 60, 0, 30)
	track.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	track.BorderSizePixel = 0
	track.Parent = container
	-- Position the track so that it is vertically centered with a margin from the right.
	track.Position = UDim2.new(1, -70, 0.5, -15)

	-- Rounded corners on the track.
	local trackCorner = Instance.new("UICorner", track)
	trackCorner.CornerRadius = UDim.new(0, 15)

	-- Subtle gradient on the track.
	local trackGradient = Instance.new("UIGradient", track)
	trackGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(40, 40, 40)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 60, 60))
	})
	trackGradient.Rotation = 90

	-- Animated border (stroke) around the track.
	local borderStroke = Instance.new("UIStroke", track)
	borderStroke.Color = Color3.fromRGB(100, 100, 100)
	borderStroke.Thickness = 2
	borderStroke.Transparency = 0.5

	-- UIScale for subtle hover effect on the track.
	local trackScale = Instance.new("UIScale", track)
	trackScale.Scale = 1

	-- Glow frame for visual flair when toggled on.
	local glow = Instance.new("Frame")
	glow.Name = "ToggleGlow"
	glow.Size = UDim2.new(1, 6, 1, 6)
	glow.Position = UDim2.new(0, -3, 0, -3)
	glow.BackgroundColor3 = Color3.fromRGB(0, 180, 255)
	glow.BackgroundTransparency = 1  -- initially hidden
	glow.Parent = track
	local glowCorner = Instance.new("UICorner", glow)
	glowCorner.CornerRadius = UDim.new(0, 15)

	-- Toggle handle (the sliding indicator)
	local handle = Instance.new("Frame")
	handle.Name = "ToggleHandle"
	handle.Size = UDim2.new(0, 26, 0, 26)
	-- Set handle color depending on state.
	handle.BackgroundColor3 = defaultState and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(200, 200, 200)
	handle.BorderSizePixel = 0
	handle.Parent = track
	local handleCorner = Instance.new("UICorner", handle)
	handleCorner.CornerRadius = UDim.new(1, 0)

	-- Optional: Add a subtle shadow for the handle.
	local handleShadow = Instance.new("ImageLabel")
	handleShadow.Name = "HandleShadow"
	handleShadow.Size = handle.Size
	handleShadow.Position = UDim2.new(0, 2, 0, 2)
	handleShadow.BackgroundTransparency = 1
	handleShadow.Image = "rbxassetid://131604521"  -- change to your desired asset ID
	handleShadow.ImageColor3 = Color3.new(0, 0, 0)
	handleShadow.ImageTransparency = 0.5
	handleShadow.Parent = handle
	handleShadow.ZIndex = handle.ZIndex - 1

	-- Define positions for off and on states.
	local offPosition = UDim2.new(0, 2, 0.5, -13)
	local onPosition  = UDim2.new(1, -28, 0.5, -13)
	handle.Position = defaultState and onPosition or offPosition

	-- Current state of the toggle.
	local state = defaultState

	--------------------------------------------------
	-- Function to update the toggle state.
	--------------------------------------------------
	local function updateToggle(newState)
		state = newState
		if state then
			-- Animate handle to "on" position.
			tween(handle, {Position = onPosition}, 0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			-- Update colors for the active state.
			tween(track, {BackgroundColor3 = Color3.fromRGB(0, 180, 255)}, 0.25)
			tween(handle, {BackgroundColor3 = Color3.fromRGB(255, 255, 255)}, 0.25)
			tween(glow, {BackgroundTransparency = 0.4}, 0.25)
			tween(borderStroke, {Color = Color3.fromRGB(0, 180, 255), Thickness = 4, Transparency = 0}, 0.25)
		else
			-- Animate handle to "off" position.
			tween(handle, {Position = offPosition}, 0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			-- Revert colors.
			tween(track, {BackgroundColor3 = Color3.fromRGB(50, 50, 50)}, 0.25)
			tween(handle, {BackgroundColor3 = Color3.fromRGB(200, 200, 200)}, 0.25)
			tween(glow, {BackgroundTransparency = 1}, 0.25)
			tween(borderStroke, {Color = Color3.fromRGB(100, 100, 100), Thickness = 2, Transparency = 0.5}, 0.25)
		end
		if callback then
			callback(state)
		end
	end

	--------------------------------------------------
	-- Connect mouse input: Toggle when track is clicked.
	--------------------------------------------------
	track.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			updateToggle(not state)
		end
	end)

	--------------------------------------------------
	-- Hover animations for a polished look.
	--------------------------------------------------
	track.MouseEnter:Connect(function()
		tween(trackScale, {Scale = 1.03}, 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		if state then
			tween(borderStroke, {Thickness = 4.5, Transparency = 0}, 0.15)
		else
			tween(borderStroke, {Thickness = 2.5, Transparency = 0.4}, 0.15)
		end
	end)
	track.MouseLeave:Connect(function()
		tween(trackScale, {Scale = 1}, 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		if state then
			tween(borderStroke, {Thickness = 4, Transparency = 0}, 0.15)
		else
			tween(borderStroke, {Thickness = 2, Transparency = 0.5}, 0.15)
		end
	end)
	
	return container
end

local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Utility tween function for smooth transitions
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.15,
		easingStyle or Enum.EasingStyle.Sine,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

-- Create a button with a smooth, professional click animation.
local function createButton(parent, opts, callback)
	opts = opts or {}

	-- Main Button Setup
	local button = Instance.new("TextButton")
	button.Name = opts.Name or "CoolButton"
	button.Size = opts.Size or UDim2.new(0, 150, 0, 50)
	button.Position = opts.Position or UDim2.new(0, 0, 0, 0)
	button.BackgroundColor3 = opts.BackgroundColor or Color3.fromRGB(0, 150, 255)
	button.Text = opts.Text or "Button"
	button.Font = opts.Font or Enum.Font.GothamBold
	button.TextSize = opts.TextSize or 18
	button.TextColor3 = opts.TextColor or Color3.fromRGB(240, 240, 240)
	button.AutoButtonColor = false
	button.Parent = parent

	-- Optional drop shadow for extra depth
	if opts.DropShadow then
		local shadow = Instance.new("Frame")
		shadow.Name = "DropShadow"
		shadow.Size = button.Size
		shadow.Position = UDim2.new(0, opts.ShadowOffsetX or 3, 0, opts.ShadowOffsetY or 3)
		shadow.BackgroundColor3 = opts.ShadowColor or Color3.new(0, 0, 0)
		shadow.BackgroundTransparency = opts.ShadowTransparency or 0.5
		shadow.ZIndex = button.ZIndex - 1
		shadow.Parent = button

		local shadowCorner = Instance.new("UICorner")
		shadowCorner.CornerRadius = opts.CornerRadius or UDim.new(0, 12)
		shadowCorner.Parent = shadow
	end

	-- Rounded corners for a modern look
	local corner = Instance.new("UICorner")
	corner.CornerRadius = opts.CornerRadius or UDim.new(0, 12)
	corner.Parent = button

	-- Subtle outline (stroke)
	local stroke = Instance.new("UIStroke")
	stroke.Thickness = opts.StrokeThickness or 2
	stroke.Color = opts.StrokeColor or Color3.fromRGB(0, 120, 200)
	stroke.Transparency = opts.StrokeTransparency or 0.4
	stroke.Parent = button

	-- Dynamic gradient background
	local gradient = Instance.new("UIGradient")
	gradient.Color = opts.GradientColor or ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 170, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 130, 255))
	})
	gradient.Rotation = opts.GradientRotation or 90
	gradient.Parent = button

	-- UIScale to allow subtle scale animations
	local scale = Instance.new("UIScale")
	scale.Scale = 1
	scale.Parent = button

	--------------------------------------
	-- Hover Effects (color, stroke & gradient)
	--------------------------------------
	button.MouseEnter:Connect(function()
		tween(button, { BackgroundColor3 = opts.HoverColor or Color3.fromRGB(0, 180, 255) }, 0.15)
		tween(stroke, { Transparency = opts.StrokeHoverTransparency or 0.2 }, 0.15)
		tween(gradient, { Rotation = opts.GradientHoverRotation or 0 }, 0.15)
	end)

	button.MouseLeave:Connect(function()
		tween(button, { BackgroundColor3 = opts.BackgroundColor or Color3.fromRGB(0, 150, 255) }, 0.15)
		tween(stroke, { Transparency = opts.StrokeTransparency or 0.4 }, 0.15)
		tween(gradient, { Rotation = opts.GradientRotation or 90 }, 0.15)
	end)

	--------------------------------------
	-- Refined Click Animation (No Ripple)
	--------------------------------------
	-- On press, slightly scale down and darken the button.
	button.MouseButton1Down:Connect(function()
		tween(scale, { Scale = opts.PressScale or 0.98 }, 0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		-- Slight darkening on press; change color to a subtle darker hue.
		local clickColor = opts.ClickColor or Color3.fromRGB(0, 140, 240)
		tween(button, { BackgroundColor3 = clickColor }, 0.08)
	end)

	-- On release, scale back to full size and revert background color.
	button.MouseButton1Up:Connect(function()
		tween(scale, { Scale = 1 }, 0.12, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		tween(button, { BackgroundColor3 = opts.BackgroundColor or Color3.fromRGB(0, 150, 255) }, 0.12)
		if callback then
			callback()
		end
	end)

	return button
end

---------------------------
-- Base UI Window & Tab System with Sections
---------------------------
-- Upgraded MainFrame with Minimize & Close Buttons, Pulsing Border, and Smooth Dragging

-- Services
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

-- Remove any previous UI.
if game.CoreGui:FindFirstChild("CometUI") then
    game.CoreGui:FindFirstChild("CometUI"):Destroy()
end

-- Create ScreenGui.
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CometUI"
screenGui.Parent = game.CoreGui
screenGui.IgnoreGuiInset = true

--------------------------------------------------
-- Main Frame (No Drop Shadow; Pulsing Border instead)
--------------------------------------------------
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Parent = screenGui
mainFrame.Size = UDim2.new(0, 500, 0, 400)
mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
mainFrame.BackgroundTransparency = 0
local mainGradient = Instance.new("UIGradient", mainFrame)
mainGradient.Rotation = 90
mainGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 50)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(38, 38, 38))
}
local mainStroke = Instance.new("UIStroke", mainFrame)
mainStroke.Thickness = 3
mainStroke.Color = Color3.fromRGB(80, 80, 80)
mainStroke.Transparency = 0.2
local mainCorner = Instance.new("UICorner", mainFrame)
mainCorner.CornerRadius = UDim.new(0, 16)

-- Pulsing Border Effect (tween the stroke's Color continuously)
spawn(function()
    while mainFrame and mainFrame.Parent do
        tween(mainStroke, {Color = Color3.fromRGB(0, 150, 255)}, 1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
        wait(1.5)
        tween(mainStroke, {Color = Color3.fromRGB(80, 80, 80)}, 1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
        wait(1.5)
    end
end)

--------------------------------------------------
-- Title Bar with Minimize & Close Buttons
--------------------------------------------------
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Parent = mainFrame
titleBar.Size = UDim2.new(1, 0, 0, 50)
titleBar.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
titleBar.BorderSizePixel = 0
local titleBarCorner = Instance.new("UICorner", titleBar)
titleBarCorner.CornerRadius = UDim.new(0, 16)
local titleGradient = Instance.new("UIGradient", titleBar)
titleGradient.Rotation = 90
titleGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(45, 45, 45)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 25, 25))
}

-- Accent Line (underline)
local accentLine = Instance.new("Frame")
accentLine.Name = "AccentLine"
accentLine.Parent = titleBar
accentLine.Size = UDim2.new(1, 0, 0, 3)
accentLine.Position = UDim2.new(0, 0, 1, -3)
accentLine.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
accentLine.BorderSizePixel = 0

local titleText = Instance.new("TextLabel")
titleText.Name = "TitleText"
titleText.Parent = titleBar
titleText.Size = UDim2.new(1, -120, 1, 0)  -- leave room for buttons
titleText.Position = UDim2.new(0, 20, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "CometWare"
titleText.TextColor3 = Color3.fromRGB(240, 240, 240)
titleText.Font = Enum.Font.GothamSemibold
titleText.TextSize = 28
titleText.TextStrokeTransparency = 0.7
titleText.TextXAlignment = Enum.TextXAlignment.Left

-- Minimize Button
local minimizeButton = Instance.new("TextButton")
minimizeButton.Name = "MinimizeButton"
minimizeButton.Parent = titleBar
minimizeButton.Size = UDim2.new(0, 30, 0, 30)
minimizeButton.Position = UDim2.new(1, -70, 0, 10)
minimizeButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
minimizeButton.Text = "–"
minimizeButton.Font = Enum.Font.GothamSemibold
minimizeButton.TextSize = 20
minimizeButton.TextColor3 = Color3.fromRGB(240, 240, 240)
local minCorner = Instance.new("UICorner", minimizeButton)
minCorner.CornerRadius = UDim.new(0, 5)
minimizeButton.MouseButton1Click:Connect(function()
    mainFrame.Visible = false
    StarterGui:SetCore("SendNotification", {
        Title = "UI Minimized",
        Text = "Press K to restore the UI.",
        Duration = 5,
    })
end)

-- Close Button
local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Parent = titleBar
closeButton.Size = UDim2.new(0, 30, 0, 30)
closeButton.Position = UDim2.new(1, -30, 0, 10)
closeButton.BackgroundColor3 = Color3.fromRGB(220, 60, 60)
closeButton.Text = "X"
closeButton.Font = Enum.Font.GothamSemibold
closeButton.TextSize = 20
closeButton.TextColor3 = Color3.fromRGB(240, 240, 240)
local closeCorner = Instance.new("UICorner", closeButton)
closeCorner.CornerRadius = UDim.new(0, 5)
closeButton.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

--------------------------------------------------
-- Tab System Containers
--------------------------------------------------
local tabButtonsFrame = Instance.new("Frame")
tabButtonsFrame.Name = "TabButtonsFrame"
tabButtonsFrame.Parent = mainFrame
tabButtonsFrame.Size = UDim2.new(1, 0, 0, 40)
tabButtonsFrame.Position = UDim2.new(0, 0, 0, 60)
tabButtonsFrame.BackgroundTransparency = 1

local tabContentFrame = Instance.new("Frame")
tabContentFrame.Name = "TabContentFrame"
tabContentFrame.Parent = mainFrame
tabContentFrame.Size = UDim2.new(1, 0, 1, -70)
tabContentFrame.Position = UDim2.new(0, 0, 0, 120)
tabContentFrame.BackgroundTransparency = 1

--------------------------------------------------
-- Smooth Dragging Integration (No Drop Shadow)
--------------------------------------------------
local dragging = false
local dragInput, dragStart, startPos
local targetPos = mainFrame.Position

-- When the title bar receives a mouse down event:
titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        targetPos = startPos  -- reset target when drag begins
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

-- Track the mouse movement on the title bar.
titleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        local delta = input.Position - dragStart
        targetPos = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

RunService.RenderStepped:Connect(function()
    if dragging then
        mainFrame.Position = mainFrame.Position:Lerp(targetPos, 0.2)
    end
end)

--------------------------------------------------
-- Base Window API
--------------------------------------------------
local windowAPI = {}
windowAPI.TabButtonsFrame = tabButtonsFrame
windowAPI.TabContentFrame = tabContentFrame
windowAPI.Tabs = {}
windowAPI.ActiveTab = nil


local TweenService = game:GetService("TweenService")

--------------------------------------------------
-- Tween helper (for smooth, crisp animations)
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.25,
		easingStyle or Enum.EasingStyle.Quad,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

--------------------------------------------------
-- Create a new tab for the window
--------------------------------------------------
local function createTab(windowAPI, tabName)
	local tab = {}
	tab.Name = tabName
	tab.Sections = {}

	---------------------------------------------------
	-- Ensure the TabButtonsFrame has a horizontal layout.
	-- (Make sure that your TabButtonsFrame is positioned
	-- under the title bar in your main UI.)
	---------------------------------------------------
	local tabButtonsFrame = windowAPI.TabButtonsFrame
	if not tabButtonsFrame:FindFirstChildOfClass("UIListLayout") then
		local listLayout = Instance.new("UIListLayout")
		listLayout.FillDirection = Enum.FillDirection.Horizontal
		listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
		listLayout.VerticalAlignment = Enum.VerticalAlignment.Center
		listLayout.Padding = UDim.new(0, 5)
		listLayout.Parent = tabButtonsFrame
	end

	-----------------------------
	-- Create the tab button:
	-----------------------------
	local tabButton = Instance.new("TextButton")
	tabButton.Name = "TabButton"
	tabButton.Text = tabName
	tabButton.Size = UDim2.new(0, 120, 1, 0) -- fixed width; height is inherited from the TabButtonsFrame
	tabButton.BackgroundColor3 = Color3.fromRGB(200, 200, 200)  -- default light gray
	tabButton.TextColor3 = Color3.fromRGB(30, 30, 30)           -- dark text for contrast
	tabButton.Font = Enum.Font.GothamBold
	tabButton.TextSize = 16
	tabButton.AutoButtonColor = false
	tabButton.Parent = tabButtonsFrame
	
	-- Add a subtle UIGradient for depth.
	local buttonGradient = Instance.new("UIGradient")
	buttonGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(200, 200, 200)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(190, 190, 190))
	})
	buttonGradient.Rotation = 90
	buttonGradient.Parent = tabButton

	-- Add smooth rounded corners.
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = tabButton

	-- Add an active indicator (a thin line at the bottom).
	local indicator = Instance.new("Frame")
	indicator.Name = "ActiveIndicator"
	indicator.Size = UDim2.new(1, 0, 0, 3)
	indicator.Position = UDim2.new(0, 0, 1, -3)
	indicator.BackgroundColor3 = Color3.fromRGB(0, 150, 255)  -- blue accent
	indicator.BackgroundTransparency = 1  -- hidden by default
	indicator.Parent = tabButton

	-- Add a subtle UIScale for hover animations.
	local scaleObj = Instance.new("UIScale")
	scaleObj.Scale = 1
	scaleObj.Parent = tabButton

	-----------------------------
	-- Smoother Hover & Active Effects:
	-----------------------------
	-- (Using 0.2 seconds for smoother transitions.)
	tabButton.MouseEnter:Connect(function()
		if windowAPI.ActiveTab ~= tab then
			tween(scaleObj, { Scale = 1.05 }, 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			tween(tabButton, { BackgroundColor3 = Color3.fromRGB(220, 220, 220) }, 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		end
	end)

	tabButton.MouseLeave:Connect(function()
		if windowAPI.ActiveTab ~= tab then
			tween(scaleObj, { Scale = 1 }, 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			tween(tabButton, { BackgroundColor3 = Color3.fromRGB(200, 200, 200) }, 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		end
	end)

	-- When a tab is clicked, animate its active state, hide other tabs’ content,
	-- and mark this one as active.
	tabButton.MouseButton1Click:Connect(function()
		-- Reset all tabs.
		for _, t in pairs(windowAPI.Tabs) do
			if t.Button then
				tween(t.Button, { BackgroundColor3 = Color3.fromRGB(200, 200, 200) }, 0.2)
				local ind = t.Button:FindFirstChild("ActiveIndicator")
				if ind then
					tween(ind, { BackgroundTransparency = 1 }, 0.2)
				end
				-- Reset scale.
				local s = t.Button:FindFirstChildOfClass("UIScale")
				if s then
					tween(s, { Scale = 1 }, 0.2)
				end
			end
			if t.Content then
				t.Content.Visible = false
			end
		end

		-- Activate this tab.
		tween(tabButton, { BackgroundColor3 = Color3.fromRGB(240, 240, 240) }, 0.2)
		if tabButton:FindFirstChild("ActiveIndicator") then
			tween(tabButton.ActiveIndicator, { BackgroundTransparency = 0 }, 0.2)
		end

		-- Show this tab's content.
		tab.Content.Visible = true
		windowAPI.ActiveTab = tab
	end)

	-- If no active tab exists yet, initialize with this one.
	local initActive = not windowAPI.ActiveTab
	if initActive then
		windowAPI.ActiveTab = tab
		tween(tabButton, { BackgroundColor3 = Color3.fromRGB(240, 240, 240) }, 0.2)
		if tabButton:FindFirstChild("ActiveIndicator") then
			tween(tabButton.ActiveIndicator, { BackgroundTransparency = 0 }, 0.2)
		end
	else
		-- Ensure non-active tab starts at the default look.
	end

	-----------------------------
	-- Create the tab content:
	-----------------------------
	-- The content area is placed inside windowAPI.TabContentFrame, which in your integrated UI
	-- is positioned below the TabButtonsFrame (and hence, below the title bar).
	local tabContent = Instance.new("ScrollingFrame")
	tabContent.Name = "TabContent_" .. tabName
	tabContent.Size = UDim2.new(1, -10, 1, -10)
	tabContent.Position = UDim2.new(0, 5, 0, 5)
	tabContent.BackgroundTransparency = 1
	tabContent.ScrollBarThickness = 4
	tabContent.Visible = initActive
	tabContent.Parent = windowAPI.TabContentFrame

	-- Use a vertical UIListLayout to neatly stack content.
	local listLayout = Instance.new("UIListLayout", tabContent)
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 5)

	-- Save references for later use.
	tab.Button = tabButton
	tab.Content = tabContent

	-----------------------------
	-- Allow adding sections:
	-----------------------------
	function tab:AddSection(sectionName)
		local section = {}
		section.Name = sectionName

		local sectionFrame = Instance.new("Frame")
		sectionFrame.Name = "Section_" .. sectionName
		sectionFrame.Size = UDim2.new(1, 0, 0, 100)  -- default height; adjust as needed
		sectionFrame.BackgroundTransparency = 1
		sectionFrame.Parent = tabContent

		-- Use a UIListLayout for neatly stacking elements.
		local sectionLayout = Instance.new("UIListLayout", sectionFrame)
		sectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
		sectionLayout.Padding = UDim.new(0, 5)

		section.Frame = sectionFrame

		-- These functions assume you have createSlider, createToggle, and createButton defined.
		function section:AddSlider(opts, callback)
			createSlider(sectionFrame, opts, callback)
		end
		function section:AddToggle(opts, callback)
			createToggle(sectionFrame, opts, callback)
		end
		function section:AddButton(opts, callback)
			createButton(sectionFrame, opts, callback)
		end

		table.insert(tab.Sections, section)
		return section
	end

	table.insert(windowAPI.Tabs, tab)
	return tab
end


--------------------------------------------------
-- Add a new tab via your windowAPI.
--------------------------------------------------
function windowAPI:AddTab(tabName)
	return createTab(self, tabName)
end

---------------------------
-- UI Visibility Toggle (RightShift)
---------------------------
-- Upgraded UI Visibility Script with Minimized Check

-- Services
local TweenService    = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local StarterGui      = game:GetService("StarterGui")
-- local Lighting        = game:GetService("Lighting")  -- Uncomment if you want to use a blur effect

--------------------------------------------------
-- Helper Tween Function
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.35,
		easingStyle or Enum.EasingStyle.Sine,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

--------------------------------------------------
-- Fade Out and Hide Function
--------------------------------------------------
local function fadeOutAndHide(ui, duration)
	duration = duration or 0.35
	-- Iterate over all GUI descendants and tween their transparencies.
	for _, descendant in ipairs(ui:GetDescendants()) do
		if descendant:IsA("GuiObject") then
			-- Store the original BackgroundTransparency if not already stored.
			if descendant.BackgroundTransparency ~= nil and descendant:GetAttribute("origBackgroundTransparency") == nil then
				descendant:SetAttribute("origBackgroundTransparency", descendant.BackgroundTransparency)
			end
			tween(descendant, { BackgroundTransparency = 1 }, duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
			-- For text objects, store and tween the TextTransparency.
			if (descendant:IsA("TextLabel") or descendant:IsA("TextButton")) and descendant.TextTransparency ~= nil then
				if descendant:GetAttribute("origTextTransparency") == nil then
					descendant:SetAttribute("origTextTransparency", descendant.TextTransparency)
				end
				tween(descendant, { TextTransparency = 1 }, duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
			end
		end
	end
	-- After tweening, disable the UI.
	delay(duration, function()
		ui.Visible = false
	end)
end

--------------------------------------------------
-- Fade In and Show Function
--------------------------------------------------
local function fadeInAndShow(ui, duration)
	duration = duration or 0.35
	ui.Visible = true
	-- Iterate over all GUI descendants and tween transparencies back to their stored values.
	for _, descendant in ipairs(ui:GetDescendants()) do
		if descendant:IsA("GuiObject") then
			local targetBg = descendant:GetAttribute("origBackgroundTransparency") or 0
			tween(descendant, { BackgroundTransparency = targetBg }, duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
			if descendant:IsA("TextLabel") or descendant:IsA("TextButton") then
				local targetText = descendant:GetAttribute("origTextTransparency") or 0
				tween(descendant, { TextTransparency = targetText }, duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
			end
		end
	end
end

--------------------------------------------------
-- Optional: Enhanced Blur Effect (Commented Out)
--------------------------------------------------
--[[
local BlurEffect = Instance.new("BlurEffect")
BlurEffect.Size = 0
BlurEffect.Parent = game.Lighting

local function setBlur(targetSize, duration)
	duration = duration or 0.35
	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local blurTween = TweenService:Create(BlurEffect, tweenInfo, { Size = targetSize })
	blurTween:Play()
end
--]]

--------------------------------------------------
-- UI Toggle Keybind Logic with Minimized Check
--------------------------------------------------
local uiVisible = true
local debounce = false

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed or input.UserInputType ~= Enum.UserInputType.Keyboard then return end
	
	if input.KeyCode == Enum.KeyCode.K and input.UserInputState == Enum.UserInputState.Begin and not debounce then
		debounce = true
		
		local cometUI = game.CoreGui:FindFirstChild("CometUI")
		if cometUI then
			local mainFrame = cometUI:FindFirstChild("MainFrame")
			-- Check if the UI is minimized (attribute "Minimized" is true)
			if mainFrame:GetAttribute("Minimized") then
				-- Restore the minimized UI.
				mainFrame:SetAttribute("Minimized", false)
				uiVisible = true
				fadeInAndShow(mainFrame, 0.35)
				-- If you use additional elements (like drop shadows), fade them in here.
			else
				-- Toggle UI visibility as usual.
				uiVisible = not uiVisible
				if uiVisible then
					fadeInAndShow(mainFrame, 0.35)
				else
					fadeOutAndHide(mainFrame, 0.35)
					StarterGui:SetCore("SendNotification", {
						Title = "UI Hidden",
						Text = "Press K to restore the UI.",
						Duration = 5,
					})
				end
			end
		end
		
		wait(0.35)
		debounce = false
	end
end)

---------------------------
-- Expose the Base Window API Globally via a CometUI module
---------------------------
local CometUI = {}
function CometUI:CreateWindow(config)
    if config then
        if config.Title then
            titleText.Text = config.Title
        end
        if config.Size then
            mainFrame.Size = config.Size
            mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
        end
    end
    return windowAPI
end

_G.baseWindow = CometUI:CreateWindow({ Title = "CometWare", Size = UDim2.new(0,500,0,400) })
print("Base UI created. Use _G.baseWindow:AddTab('Tab Name') to add a new tab.")
