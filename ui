local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local loadingGui = Instance.new("ScreenGui")
loadingGui.Name = "CometLoadingGui"
loadingGui.Parent = game.CoreGui
loadingGui.IgnoreGuiInset = true

local container = Instance.new("Frame")
container.Name = "Container"
container.Parent = loadingGui
container.AnchorPoint = Vector2.new(0.5, 0.5)
container.Position = UDim2.new(0.5, 0, 0.5, 0)
container.Size = UDim2.new(0, 0, 0, 0)
container.BackgroundTransparency = 1

local cometLabel = Instance.new("TextLabel")
cometLabel.Name = "CometLabel"
cometLabel.Parent = container
cometLabel.Size = UDim2.new(1, 0, 0, 140)
cometLabel.Position = UDim2.new(0, 0, 0, 0)
cometLabel.BackgroundTransparency = 1
cometLabel.Text = "Comet"
cometLabel.Font = Enum.Font.ArimoBold
cometLabel.TextSize = 144
cometLabel.TextColor3 = Color3.fromRGB(240,240,240)
cometLabel.TextStrokeColor3 = Color3.new(0,0,0)
cometLabel.TextStrokeTransparency = 0.3
cometLabel.TextTransparency = 1
cometLabel.ZIndex = 2

local cometGradient = Instance.new("UIGradient", cometLabel)
cometGradient.Rotation = 0
cometGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0,0,0)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0,122,255)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0,0,0))
})
cometGradient.Offset = Vector2.new(-1, 0)

local executorName = identifyexecutor() or "Unknown Executor"
local executorLabel = Instance.new("TextLabel")
executorLabel.Name = "ExecutorLabel"
executorLabel.Parent = container
executorLabel.Size = UDim2.new(1, 0, 0, 60)
executorLabel.Position = UDim2.new(0, 0, 0, 145)
executorLabel.BackgroundTransparency = 1
executorLabel.Text = executorName
executorLabel.Font = Enum.Font.ArimoBold
executorLabel.TextSize = 28
executorLabel.TextColor3 = Color3.fromRGB(230,230,230)
executorLabel.TextStrokeColor3 = Color3.new(0,0,0)
executorLabel.TextStrokeTransparency = 0.3
executorLabel.TextTransparency = 1
executorLabel.ZIndex = 2

local executorGradient = Instance.new("UIGradient", executorLabel)
executorGradient.Rotation = 0
executorGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0,0,0)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0,200,255)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0,0,0))
})
executorGradient.Offset = Vector2.new(-1, 0)

local popInTween = TweenService:Create(container, TweenInfo.new(1, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out), {Size = UDim2.new(0,500,0,220)})
popInTween:Play()
popInTween.Completed:Connect(function()
	local fadeInComet = TweenService:Create(cometLabel, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextTransparency = 0})
	local fadeInExecutor = TweenService:Create(executorLabel, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextTransparency = 0})
	fadeInComet:Play()
	fadeInExecutor:Play()
end)

local startTime = tick()
local renderConn = RunService.RenderStepped:Connect(function()
	local t = tick() - startTime
	local cometOff = math.sin(t * 2) * 1
	cometGradient.Offset = Vector2.new(cometOff, 0)
	cometLabel.TextSize = 144 + 8 * math.sin(t * 3)
	local execOff = math.cos(t * 2.5) * 1
	executorGradient.Offset = Vector2.new(execOff, 0)
	local bob = math.sin(t * 2) * 4
	executorLabel.Position = UDim2.new(0, 0, 0, 100 + bob)
	local containerRot = math.sin(t) * 2
	container.Rotation = containerRot
end)

wait(3)

local fadeOutTweenComet = TweenService:Create(cometLabel, TweenInfo.new(0.75, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {TextTransparency = 1, TextStrokeTransparency = 1})
local fadeOutTweenExecutor = TweenService:Create(executorLabel, TweenInfo.new(0.75, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {TextTransparency = 1, TextStrokeTransparency = 1})
fadeOutTweenComet:Play()
	fadeOutTweenExecutor:Play()
fadeOutTweenExecutor.Completed:Connect(function()
	renderConn:Disconnect()
	local shrinkTween = TweenService:Create(container, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Size = UDim2.new(0,0,0,0), Rotation = 0})
	shrinkTween:Play()
	shrinkTween.Completed:Connect(function()
		loadingGui:Destroy()
	end)
end)




---------------------------
-- SERVICES & UTILITY FUNCTIONS
---------------------------
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Modified tween function now supports an optional callback
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
    local info = TweenInfo.new(
        duration or 0.2,
        easingStyle or Enum.EasingStyle.Sine,
        easingDirection or Enum.EasingDirection.Out,
        0,
        false,
        delay or 0
    )
    local tw = TweenService:Create(object, info, properties)
    if callback then
        tw.Completed:Connect(callback)
    end
    tw:Play()
    return tw
end

---------------------------
-- UI ELEMENT FUNCTIONS
---------------------------


local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

--------------------------------------------------
-- Helper Tween Function
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.25,
		easingStyle or Enum.EasingStyle.Quad,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

--------------------------------------------------
-- createSlider Function (Polished Version)
--------------------------------------------------
local function createSlider(parent, opts, callback)
	opts = opts or {}
	local min = opts.Min or 0
	local max = opts.Max or 100
	local defaultValue = opts.Default or 50
	local sliderLabel = opts.Label or "Slider"
	local initPercent = (defaultValue - min) / (max - min)
	local sliderHeight = opts.Organization and 80 or 100

	local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
		local ti = TweenInfo.new(duration, easingStyle or Enum.EasingStyle.Sine, easingDirection or Enum.EasingDirection.Out, 0, false, delay or 0)
		local t = game:GetService("TweenService"):Create(object, ti, properties)
		t:Play()
		if callback then
			t.Completed:Connect(callback)
		end
		return t
	end

	-- Outer Container
	local slider = Instance.new("Frame")
	slider.Name = "Slider"
	slider.Size = opts.Size or UDim2.new(0, 320, 0, sliderHeight)
	slider.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	slider.BackgroundTransparency = 0
	slider.ClipsDescendants = true
	slider.ZIndex = 10
	slider.Parent = parent

	-- Container Border & Rounded Corners
-- Assume "slider" is an existing Frame representing your slider container.
-- For demonstration, we assume slider is already parented to an appropriate parent.
-- (Make sure to adjust "parent" or the initial properties if necessary.)

-- Assume "slider" is your slider container (a Frame) already created and parented appropriately.
-- Also assume you have a helper function "tween" defined (or replace with TweenService:Create calls directly).
local TweenService = game:GetService("TweenService")

-----------------------------------------------------------
-- SLIDER CONTAINER STYLING
-----------------------------------------------------------
-- Create and configure the UIStroke on the slider.
local containerStroke = Instance.new("UIStroke", slider)
containerStroke.Thickness = 2
containerStroke.Color = Color3.fromRGB(100, 100, 100)  -- initial color
containerStroke.Transparency = 0.2

-- Animate the stroke to pulse like your accentLine.
local strokeColorTween = TweenService:Create(
	containerStroke,
	TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
	{ Color = Color3.fromRGB(0, 200, 255) }
)
strokeColorTween:Play()

local strokeTransparencyTween = TweenService:Create(
	containerStroke,
	TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
	{ Transparency = 0.15 }
)
strokeTransparencyTween:Play()

-- Add rounded corners.
local containerCorner = Instance.new("UICorner", slider)
containerCorner.CornerRadius = UDim.new(0, 10)

-- Add a gradient background for extra depth.
local sliderGradient = Instance.new("UIGradient", slider)
sliderGradient.Rotation = 90
sliderGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 30)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 20))
})

-----------------------------------------------------------
-- HOVER & INTERACTION EFFECTS
-----------------------------------------------------------
-- Create a UIScale object to animate a subtle zoom on hover.
local scaleObj = Instance.new("UIScale", slider)
scaleObj.Scale = 1

slider.MouseEnter:Connect(function()
	-- Tween scale up.
	tween(scaleObj, { Scale = 1.02 }, 0.2)
	-- Optionally, tween the gradient to a slightly brighter tone.
	tween(sliderGradient, { Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(40, 40, 40)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(30, 30, 30))
	})}, 0.2)
end)

slider.MouseLeave:Connect(function()
	-- Tween scale back to normal.
	tween(scaleObj, { Scale = 1 }, 0.2)
	-- Revert gradient colors.
	tween(sliderGradient, { Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 30)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 20))
	})}, 0.2)
end)

-----------------------------------------------------------
-- CONTENT CONTAINER SETUP
-----------------------------------------------------------
local content = Instance.new("Frame")
content.Name = "Content"
content.Size = UDim2.new(1, 0, 0, 20)  -- Only occupies the top portion (20 pixels high)
content.Position = UDim2.new(0, 0, 0, 0)
content.BackgroundTransparency = 1
content.ZIndex = slider.ZIndex + 4
content.Parent = slider



	local padding = Instance.new("UIPadding", content)
	if opts.Organization then
		padding.PaddingLeft = UDim.new(0, 6)
		padding.PaddingRight = UDim.new(0, 6)
		padding.PaddingTop = UDim.new(0, 4)
		padding.PaddingBottom = UDim.new(0, 4)
	else
		padding.PaddingLeft = UDim.new(0, 10)
		padding.PaddingRight = UDim.new(0, 10)
		padding.PaddingTop = UDim.new(0, 10)
		padding.PaddingBottom = UDim.new(0, 10)
	end

	local layout = Instance.new("UIListLayout", content)
	layout.FillDirection = Enum.FillDirection.Vertical
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 4)

	if opts.Organization and opts.OrgLabel then
		local orgLabel = Instance.new("TextLabel")
		orgLabel.Name = "OrganizationLabel"
		orgLabel.Size = UDim2.new(1, 0, 0, 20)
		orgLabel.BackgroundTransparency = 1
		orgLabel.Text = opts.OrgLabel
		orgLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
		orgLabel.Font = Enum.Font.GothamBold
		orgLabel.TextSize = 18
		orgLabel.TextXAlignment = Enum.TextXAlignment.Left
		orgLabel.ZIndex = content.ZIndex
		orgLabel.Parent = content
	end

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Size = UDim2.new(1, 0, 0, 35)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = sliderLabel
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 26
	titleLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextStrokeTransparency = 0.8
	titleLabel.ZIndex = content.ZIndex
	titleLabel.Parent = content

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local valueLabel = Instance.new("TextLabel")
valueLabel.Name = "ValueLabel"
valueLabel.Size = UDim2.new(1, 0, 0, 25)
valueLabel.BackgroundTransparency = 1
valueLabel.Text = tostring(defaultValue)
valueLabel.Font = Enum.Font.GothamSemibold
valueLabel.TextSize = 22
valueLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
valueLabel.TextXAlignment = Enum.TextXAlignment.Left
valueLabel.TextStrokeTransparency = 0.8
valueLabel.ZIndex = content.ZIndex
valueLabel.Parent = content

-- Add a gradient to give the text a dynamic, shimmering effect.
local valueGradient = Instance.new("UIGradient", valueLabel)
valueGradient.Rotation = 0
valueGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 150, 255)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(240, 240, 240)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 150, 255))
})
-- Start the gradient offset off to the left.
valueGradient.Offset = Vector2.new(-0.3, 0)

-- Continuously animate the gradient's offset for a smooth shimmer.
coroutine.wrap(function()
	while valueLabel and valueLabel.Parent do
		local tweenForward = TweenService:Create(valueGradient, TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Offset = Vector2.new(0.3, 0)})
		tweenForward:Play()
		tweenForward.Completed:Wait()
		local tweenBackward = TweenService:Create(valueGradient, TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Offset = Vector2.new(-0.3, 0)})
		tweenBackward:Play()
		tweenBackward.Completed:Wait()
	end
end)()

-- Add a UIScale for a pulsing effect when the value updates.
local valueScale = Instance.new("UIScale", valueLabel)
valueScale.Scale = 1

-- Function to update the valueLabel with a cool pulse and number-switch animation.
-- Call updateValueLabel(newValue) whenever you need to update the slider's value.
local function updateValueLabel(newValue)
	-- Pulse up
	local pulseUp = TweenService:Create(valueScale, TweenInfo.new(0.1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Scale = 1.3})
	-- Pulse down
	local pulseDown = TweenService:Create(valueScale, TweenInfo.new(0.1, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {Scale = 1})
	
	pulseUp:Play()
	pulseUp.Completed:Wait()
	-- Update the displayed value
	valueLabel.Text = tostring(newValue)
	pulseDown:Play()
end

-- Example usage (replace with your actual update logic):
-- updateValueLabel(75)


	-- Track (Slider Bar)
	local track = Instance.new("Frame")
	track.Name = "Track"
	track.Size = UDim2.new(1, -20, 0, 12)
	track.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
	track.BorderSizePixel = 0
	track.ZIndex = content.ZIndex
	track.Parent = content

	local trackCorner = Instance.new("UICorner", track)
	trackCorner.CornerRadius = UDim.new(0, 6)

	local trackGradient = Instance.new("UIGradient", track)
	trackGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 80, 80)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 60, 60))
	})
	trackGradient.Rotation = 90

	-- Fill inside the Track
	local fill = Instance.new("Frame")
	fill.Name = "Fill"
	fill.Size = UDim2.new(initPercent, 0, 1, 0)
	fill.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
	fill.BorderSizePixel = 0
	fill.ZIndex = track.ZIndex + 1
	fill.Parent = track

	local fillCorner = Instance.new("UICorner", fill)
	fillCorner.CornerRadius = UDim.new(0, 6)

	local fillGradient = Instance.new("UIGradient", fill)
	fillGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 180, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 120, 255))
	})
	fillGradient.Rotation = 90

	-- Draggable Handle
	local handle = Instance.new("TextButton")
	handle.Name = "Handle"
	handle.Size = UDim2.new(0, 20, 0, 20)
	handle.AnchorPoint = Vector2.new(0.5, 0.5)
	handle.Position = UDim2.new(initPercent, 0, 0.5, 0)
	handle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	handle.BorderSizePixel = 0
	handle.AutoButtonColor = false
	handle.Text = ""
	handle.ZIndex = track.ZIndex + 2
	handle.Parent = track

	local handleCorner = Instance.new("UICorner", handle)
	handleCorner.CornerRadius = UDim.new(1, 0)

	local handleStroke = Instance.new("UIStroke", handle)
	handleStroke.Color = Color3.fromRGB(0, 150, 255)
	handleStroke.Thickness = 2
	handleStroke.Transparency = 0.5

	-- Tooltip (appears above the handle when dragging)
	local tooltip = Instance.new("TextLabel")
	tooltip.Name = "Tooltip"
	tooltip.Size = UDim2.new(0, 50, 0, 20)
	tooltip.Position = UDim2.new(0, 0, 0, -25)
	tooltip.BackgroundTransparency = 1
	tooltip.TextColor3 = Color3.fromRGB(255, 255, 255)
	tooltip.Font = Enum.Font.GothamBold
	tooltip.TextSize = 18
	tooltip.Text = tostring(defaultValue)
	tooltip.Visible = false
	tooltip.ZIndex = handle.ZIndex + 1
	tooltip.Parent = track

-- At the top of your module or script, declare renderConn in a persistent scope:
local renderConn

-- Before creating a new connection, disconnect any existing one.
if renderConn and renderConn.Connected then
    renderConn:Disconnect()
    renderConn = nil
end

local RunService = game:GetService("RunService")

-- Assume these variables are defined:
-- initPercent, slider, fill, handle, tooltip

local targetPercent = initPercent
local currentPercent = initPercent

renderConn = RunService.RenderStepped:Connect(function()
    -- Check if 'slider' exists and has a parent.
    if slider and slider.Parent then
        currentPercent = currentPercent + (targetPercent - currentPercent) * 0.6
        fill.Size = UDim2.new(currentPercent, 0, 1, 0)
        handle.Position = UDim2.new(currentPercent, 0, 0.5, 0)
        if tooltip and tooltip.Visible then
            tooltip.Position = UDim2.new(currentPercent, 0, 0, -25)
        end
    else
        -- If slider is missing, disconnect the RenderStepped connection safely.
        if renderConn then
            renderConn:Disconnect()
            renderConn = nil
        end
    end
end)


	-- Dragging logic and updating value
	local dragging = false
	local function updateValueFromInput(input)
		local absX = track.AbsolutePosition.X
		local width = track.AbsoluteSize.X
		local mouseX = input.Position.X
		local pos = math.clamp(mouseX - absX, 0, width)
		local percent = pos / width
		
		if opts.Snap and opts.Increment then
			local rawValue = min + (max - min) * percent
			local snappedValue = math.floor(rawValue / opts.Increment + 0.5) * opts.Increment
			percent = (snappedValue - min) / (max - min)
			valueLabel.Text = tostring(snappedValue)
			tooltip.Text = tostring(snappedValue)
			targetPercent = percent
			if callback then callback(snappedValue) end
		else
			targetPercent = percent
			local value = math.floor(min + (max - min) * percent)
			valueLabel.Text = tostring(value)
			tooltip.Text = tostring(value)
			if callback then callback(value) end
		end
	end

	handle.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			tooltip.Visible = true
			tween(handle, {Size = UDim2.new(0, 26, 0, 26)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		end
	end)

	handle.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = false
			tooltip.Visible = false
			tween(handle, {Size = UDim2.new(0, 20, 0, 20)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		end
	end)

	track.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			updateValueFromInput(input)
			tween(handle, {Size = UDim2.new(0, 26, 0, 26)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, function()
				if not dragging then
					tween(handle, {Size = UDim2.new(0, 20, 0, 20)}, 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
				end
			end)
		end
	end)

	game:GetService("UserInputService").InputChanged:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
			updateValueFromInput(input)
		end
	end)

	return slider
end


local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

--------------------------------------------------
-- Helper Tween Function
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.25,
		easingStyle or Enum.EasingStyle.Quad,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

--------------------------------------------------
-- createToggle Function (Repositioned for Better Layout)
--------------------------------------------------
local TweenService = game:GetService("TweenService")

--[[
    Advanced Toggle Creation Function
    ===================================
    This function creates a highly advanced toggle UI element with:
      - A dark container with an animated pulsing stroke (mirroring the slider style)
      - A refined gradient background and drop shadow for depth
      - A label placed flush with the toggle track (minimized gap)
      - An advanced toggle track with its own animated stroke and gradient
      - A sliding toggle handle with subtle shadow effects
      - Hover animations on the track (scaling and animated border changes)
      - Toggle behavior that calls a callback with the new state
    The function ends by declaring "local state = defaultState" so that external code
    relying on that variable can run correctly.
    
    Usage:
      local toggle, state = createToggle(parent, opts, callback)
      
    opts table keys:
      - Label (string): text for the label (default: "Toggle")
      - Default (boolean): initial toggle state (default: false)
      - Size (UDim2): size of the container (default: UDim2.new(1, 0, 0, 40))
      - Font, TextSize, TextColor, TextStrokeColor, TextStrokeTransparency: for the label.
      
    callback(newState) is called when the toggle is flipped.
    
    Enjoy the advanced toggle!
    
    (This function is intentionally long and advanced.)
]]--

--[[
  Advanced Toggle Creation Function
  ===================================
  This function creates a complex, highly polished toggle UI element.
  It uses an animated pulsing stroke (like your slider), a refined gradient,
  drop shadows, and a layout that places the label flush next to the toggle track.
  
  All toggle state change handling (click callbacks) is omitted so that your own
  code may manage the toggle behavior. The function simply creates the UI element
  and returns the container and the initial state.

  At the very end, the code declares "local state = defaultState" so that external code 
  relying on that variable can function properly.
  
  Usage:
    local toggleContainer, state = createToggle(parent, opts)
  
  opts table keys:
    - Label (string): text for the label (default: "Toggle")
    - Default (boolean): initial toggle state (default: false)
    - Size (UDim2): size of the outer container (default: UDim2.new(1, 0, 0, 40))
    - Font, TextSize, TextColor, TextStrokeColor, TextStrokeTransparency: styling for the label.
  
  Enjoy your extremely advanced toggle!
  
  (This code does NOT automatically toggle the state on click – you may handle that externally.)
]]--

local function createToggle(parent, opts)
    opts = opts or {}
    local labelText = opts.Label or "Toggle"
    local defaultState = opts.Default or false
    local TweenService = game:GetService("TweenService")

    --------------------------------------------------------------------------
    -- 1. Outer Container Setup
    --------------------------------------------------------------------------
    local container = Instance.new("Frame")
    container.Name = "ToggleContainer"
    container.Size = opts.Size or UDim2.new(1, 0, 0, 40)
    container.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    container.BackgroundTransparency = 0
    container.Parent = parent

    --------------------------------------------------------------------------
    -- 2. Animated Stroke (Mirroring the Slider’s Effect)
    --------------------------------------------------------------------------
    local containerStroke = Instance.new("UIStroke", container)
    containerStroke.Thickness = 2
    containerStroke.Color = Color3.fromRGB(100, 100, 100)  -- initial color
    containerStroke.Transparency = 0.2

    local strokeColorTween = TweenService:Create(
        containerStroke,
        TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
        { Color = Color3.fromRGB(0, 200, 255) }
    )
    strokeColorTween:Play()

    local strokeTransparencyTween = TweenService:Create(
        containerStroke,
        TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
        { Transparency = 0.15 }
    )
    strokeTransparencyTween:Play()

    --------------------------------------------------------------------------
    -- 3. Rounded Corners & Gradient Background
    --------------------------------------------------------------------------
    local containerCorner = Instance.new("UICorner", container)
    containerCorner.CornerRadius = UDim.new(0, 10)

    local containerGradient = Instance.new("UIGradient", container)
    containerGradient.Rotation = 90
    containerGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 30)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 20))
    })

    --------------------------------------------------------------------------
    -- 4. Drop Shadow for Depth
    --------------------------------------------------------------------------
    local shadow = Instance.new("Frame")
    shadow.Name = "ToggleShadow"
    shadow.Size = container.Size
    shadow.Position = UDim2.new(0, 4, 0, 4)
    shadow.BackgroundColor3 = Color3.new(0, 0, 0)
    shadow.BackgroundTransparency = 0.5
    shadow.BorderSizePixel = 0
    shadow.ZIndex = container.ZIndex - 1
    shadow.Parent = container

    --------------------------------------------------------------------------
    -- 5. Label: Positioned on the Left, Immediately Adjacent to Toggle Track
    --------------------------------------------------------------------------
    local label = Instance.new("TextLabel")
    label.Name = "ToggleLabel"
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.Font = opts.Font or Enum.Font.GothamBold
    label.TextSize = opts.TextSize or 20
    label.TextColor3 = opts.TextColor or Color3.fromRGB(240, 240, 240)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextStrokeColor3 = opts.TextStrokeColor or Color3.new(0, 0, 0)
    label.TextStrokeTransparency = opts.TextStrokeTransparency or 0.8
    -- Reserve only a small gap for the toggle track. Adjust this value as needed.
    local gap = 65  -- This is the total width reserved on the right for the toggle track.
    label.Size = UDim2.new(1, -gap, 1, 0)
    label.Position = UDim2.new(0, 10, 0, 0)
    label.Parent = container

    --------------------------------------------------------------------------
    -- 6. Toggle Track: Immediately Next to the Label
    --------------------------------------------------------------------------
    local track = Instance.new("Frame")
    track.Name = "ToggleTrack"
    track.Size = UDim2.new(0, 60, 0, 30)
    track.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    track.BorderSizePixel = 0
    track.Parent = container
    -- Position the track so that it appears at the right edge of the container (with reserved gap)
    track.Position = UDim2.new(1, -70, 0.5, -15)

    local trackCorner = Instance.new("UICorner", track)
    trackCorner.CornerRadius = UDim.new(0, 15)

    local trackGradient = Instance.new("UIGradient", track)
    trackGradient.Rotation = 90
    trackGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(40, 40, 40)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 60, 60))
    })

    --------------------------------------------------------------------------
    -- 7. Animated Border on Track (Matching the Slider)
    --------------------------------------------------------------------------
    local borderStroke = Instance.new("UIStroke", track)
    borderStroke.Color = Color3.fromRGB(100, 100, 100)
    borderStroke.Thickness = 2
    borderStroke.Transparency = 0.5

    --------------------------------------------------------------------------
    -- 8. (Optional) UIScale for Track Hover Effects
    --------------------------------------------------------------------------
    local trackScale = Instance.new("UIScale", track)
    trackScale.Scale = 1

    track.MouseEnter:Connect(function()
        TweenService:Create(trackScale, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1.03}):Play()
        TweenService:Create(borderStroke, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Thickness = 2.5, Transparency = 0.4}):Play()
    end)
    track.MouseLeave:Connect(function()
        TweenService:Create(trackScale, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1}):Play()
        TweenService:Create(borderStroke, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Thickness = 2, Transparency = 0.5}):Play()
    end)

    --------------------------------------------------------------------------
    -- 9. Glow Frame: For Visual Flair (Optional)
    --------------------------------------------------------------------------
    local glow = Instance.new("Frame")
    glow.Name = "ToggleGlow"
    glow.Size = UDim2.new(1, 6, 1, 6)
    glow.Position = UDim2.new(0, -3, 0, -3)
    glow.BackgroundColor3 = Color3.fromRGB(0, 180, 255)
    glow.BackgroundTransparency = 1  -- Initially hidden
    glow.Parent = track
    local glowCorner = Instance.new("UICorner", glow)
    glowCorner.CornerRadius = UDim.new(0, 15)

    --------------------------------------------------------------------------
    -- 10. Toggle Handle: The Sliding Indicator
    --------------------------------------------------------------------------
    local handle = Instance.new("Frame")
    handle.Name = "ToggleHandle"
    handle.Size = UDim2.new(0, 26, 0, 26)
    handle.BackgroundColor3 = defaultState and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(200, 200, 200)
    handle.BorderSizePixel = 0
    handle.Parent = track
    local handleCorner = Instance.new("UICorner", handle)
    handleCorner.CornerRadius = UDim.new(1, 0)

    --------------------------------------------------------------------------
    -- 11. Handle Shadow: For Extra Depth
    --------------------------------------------------------------------------
    local handleShadow = Instance.new("ImageLabel")
    handleShadow.Name = "HandleShadow"
    handleShadow.Size = handle.Size
    handleShadow.Position = UDim2.new(0, 2, 0, 2)
    handleShadow.BackgroundTransparency = 1
    handleShadow.Image = "rbxassetid://131604521"  -- Change this to your desired asset ID
    handleShadow.ImageColor3 = Color3.new(0, 0, 0)
    handleShadow.ImageTransparency = 0.5
    handleShadow.Parent = handle
    handleShadow.ZIndex = handle.ZIndex - 1

    --------------------------------------------------------------------------
    -- 12. Define Positions for Off and On States of the Handle
    --------------------------------------------------------------------------
    local offPosition = UDim2.new(0, 2, 0.5, -13)
    local onPosition  = UDim2.new(1, -28, 0.5, -13)
    handle.Position = defaultState and onPosition or offPosition

    --------------------------------------------------------------------------
    -- 13. Final State Declaration for External Code Compatibility
    --------------------------------------------------------------------------
    local state = defaultState


	--------------------------------------------------
	-- Function to update the toggle state.
	--------------------------------------------------
	local function updateToggle(newState)
		state = newState
		if state then
			-- Animate handle to "on" position.
			tween(handle, {Position = onPosition}, 0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			-- Update colors for the active state.
			tween(track, {BackgroundColor3 = Color3.fromRGB(0, 180, 255)}, 0.25)
			tween(handle, {BackgroundColor3 = Color3.fromRGB(255, 255, 255)}, 0.25)
			tween(glow, {BackgroundTransparency = 0.4}, 0.25)
			tween(borderStroke, {Color = Color3.fromRGB(0, 180, 255), Thickness = 4, Transparency = 0}, 0.25)
		else
			-- Animate handle to "off" position.
			tween(handle, {Position = offPosition}, 0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			-- Revert colors.
			tween(track, {BackgroundColor3 = Color3.fromRGB(50, 50, 50)}, 0.25)
			tween(handle, {BackgroundColor3 = Color3.fromRGB(200, 200, 200)}, 0.25)
			tween(glow, {BackgroundTransparency = 1}, 0.25)
			tween(borderStroke, {Color = Color3.fromRGB(100, 100, 100), Thickness = 2, Transparency = 0.5}, 0.25)
		end
		if callback then
			callback(state)
		end
	end

	--------------------------------------------------
	-- Connect mouse input: Toggle when track is clicked.
	--------------------------------------------------
	track.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			updateToggle(not state)
		end
	end)

	--------------------------------------------------
	-- Hover animations for a polished look.
	--------------------------------------------------
	track.MouseEnter:Connect(function()
		tween(trackScale, {Scale = 1.03}, 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		if state then
			tween(borderStroke, {Thickness = 4.5, Transparency = 0}, 0.15)
		else
			tween(borderStroke, {Thickness = 2.5, Transparency = 0.4}, 0.15)
		end
	end)
	track.MouseLeave:Connect(function()
		tween(trackScale, {Scale = 1}, 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		if state then
			tween(borderStroke, {Thickness = 4, Transparency = 0}, 0.15)
		else
			tween(borderStroke, {Thickness = 2, Transparency = 0.5}, 0.15)
		end
	end)
	
	return container
end

local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Utility tween function for smooth transitions
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.15,
		easingStyle or Enum.EasingStyle.Sine,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

-- Create a button with a smooth, professional click animation.
local function createButton(parent, opts, callback)
	opts = opts or {}

	-- Main Button Setup
	local button = Instance.new("TextButton")
	button.Name = opts.Name or "CoolButton"
	button.Size = opts.Size or UDim2.new(0, 150, 0, 50)
	button.Position = opts.Position or UDim2.new(0, 0, 0, 0)
	button.BackgroundColor3 = opts.BackgroundColor or Color3.fromRGB(0, 150, 255)
	button.Text = opts.Text or "Button"
	button.Font = opts.Font or Enum.Font.GothamBold
	button.TextSize = opts.TextSize or 18
	button.TextColor3 = opts.TextColor or Color3.fromRGB(240, 240, 240)
	button.AutoButtonColor = false
	button.Parent = parent

	-- Optional drop shadow for extra depth
	if opts.DropShadow then
		local shadow = Instance.new("Frame")
		shadow.Name = "DropShadow"
		shadow.Size = button.Size
		shadow.Position = UDim2.new(0, opts.ShadowOffsetX or 3, 0, opts.ShadowOffsetY or 3)
		shadow.BackgroundColor3 = opts.ShadowColor or Color3.new(0, 0, 0)
		shadow.BackgroundTransparency = opts.ShadowTransparency or 0.5
		shadow.ZIndex = button.ZIndex - 1
		shadow.Parent = button

		local shadowCorner = Instance.new("UICorner")
		shadowCorner.CornerRadius = opts.CornerRadius or UDim.new(0, 12)
		shadowCorner.Parent = shadow
	end

	-- Rounded corners for a modern look
	local corner = Instance.new("UICorner")
	corner.CornerRadius = opts.CornerRadius or UDim.new(0, 12)
	corner.Parent = button

	-- Subtle outline (stroke)
	local stroke = Instance.new("UIStroke")
	stroke.Thickness = opts.StrokeThickness or 2
	stroke.Color = opts.StrokeColor or Color3.fromRGB(0, 120, 200)
	stroke.Transparency = opts.StrokeTransparency or 0.4
	stroke.Parent = button

	-- Dynamic gradient background
	local gradient = Instance.new("UIGradient")
	gradient.Color = opts.GradientColor or ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 170, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 130, 255))
	})
	gradient.Rotation = opts.GradientRotation or 90
	gradient.Parent = button

	-- UIScale to allow subtle scale animations
	local scale = Instance.new("UIScale")
	scale.Scale = 1
	scale.Parent = button

	--------------------------------------
	-- Hover Effects (color, stroke & gradient)
	--------------------------------------
	button.MouseEnter:Connect(function()
		tween(button, { BackgroundColor3 = opts.HoverColor or Color3.fromRGB(0, 180, 255) }, 0.15)
		tween(stroke, { Transparency = opts.StrokeHoverTransparency or 0.2 }, 0.15)
		tween(gradient, { Rotation = opts.GradientHoverRotation or 0 }, 0.15)
	end)

	button.MouseLeave:Connect(function()
		tween(button, { BackgroundColor3 = opts.BackgroundColor or Color3.fromRGB(0, 150, 255) }, 0.15)
		tween(stroke, { Transparency = opts.StrokeTransparency or 0.4 }, 0.15)
		tween(gradient, { Rotation = opts.GradientRotation or 90 }, 0.15)
	end)

	--------------------------------------
	-- Refined Click Animation (No Ripple)
	--------------------------------------
	-- On press, slightly scale down and darken the button.
	button.MouseButton1Down:Connect(function()
		tween(scale, { Scale = opts.PressScale or 0.98 }, 0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		-- Slight darkening on press; change color to a subtle darker hue.
		local clickColor = opts.ClickColor or Color3.fromRGB(0, 140, 240)
		tween(button, { BackgroundColor3 = clickColor }, 0.08)
	end)

	-- On release, scale back to full size and revert background color.
	button.MouseButton1Up:Connect(function()
		tween(scale, { Scale = 1 }, 0.12, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		tween(button, { BackgroundColor3 = opts.BackgroundColor or Color3.fromRGB(0, 150, 255) }, 0.12)
		if callback then
			callback()
		end
	end)

	return button
end

---------------------------
-- Color Picker 
---------------------------
local function createColorPicker(opts, callback)
	opts = opts or {}
	local labelText = opts.Label or "Color Picker"
	local defaultColor = opts.Default or Color3.fromRGB(0,150,255)
	local size = opts.Size or UDim2.new(0,200,0,200)
	
	-- Container for the color picker
	local container = Instance.new("Frame")
	container.Name = "ColorPickerContainer"
	container.Size = size
	container.BackgroundColor3 = Color3.fromRGB(20,20,20)
	container.BorderSizePixel = 0
	container.Parent = opts.Parent or game.Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("ScreenGui")
	
	-- Label at the top
	local label = Instance.new("TextLabel")
	label.Name = "PickerLabel"
	label.Size = UDim2.new(1,0,0,25)
	label.Position = UDim2.new(0,0,0,0)
	label.BackgroundTransparency = 1
	label.Text = labelText
	label.Font = Enum.Font.GothamBold
	label.TextSize = 22
	label.TextColor3 = Color3.fromRGB(240,240,240)
	label.Parent = container
	
	-- The main area for picking a color
	local pickerFrame = Instance.new("Frame")
	pickerFrame.Name = "PickerFrame"
	pickerFrame.Size = UDim2.new(1,0,1,-25)
	pickerFrame.Position = UDim2.new(0,0,0,25)
	pickerFrame.BackgroundColor3 = Color3.new(1,1,1)
	pickerFrame.BackgroundTransparency = 0
	pickerFrame.BorderSizePixel = 0
	pickerFrame.Parent = container
	
	-- Full-spectrum hue gradient
	local hueGradient = Instance.new("UIGradient", pickerFrame)
	hueGradient.Rotation = 0
	hueGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.new(1,0,0)),       -- Red
		ColorSequenceKeypoint.new(0.17, Color3.new(1,1,0)),      -- Yellow
		ColorSequenceKeypoint.new(0.34, Color3.new(0,1,0)),      -- Green
		ColorSequenceKeypoint.new(0.51, Color3.new(0,1,1)),      -- Cyan
		ColorSequenceKeypoint.new(0.68, Color3.new(0,0,1)),      -- Blue
		ColorSequenceKeypoint.new(0.85, Color3.new(1,0,1)),      -- Magenta
		ColorSequenceKeypoint.new(1, Color3.new(1,0,0))          -- Back to Red
	})
	
	-- Overlay for saturation/value control
	local overlay = Instance.new("Frame", pickerFrame)
	overlay.Name = "SaturationOverlay"
	overlay.Size = UDim2.new(1,0,1,0)
	overlay.Position = UDim2.new(0,0,0,0)
	overlay.BackgroundTransparency = 1
	overlay.ZIndex = 2
	
	local overlayGradient = Instance.new("UIGradient", overlay)
	overlayGradient.Rotation = 90
	overlayGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.new(1,1,1)),  -- full brightness/saturation
		ColorSequenceKeypoint.new(1, Color3.new(0,0,0))   -- dark
	})
	
	-- Display for the currently selected color (optional visual feedback)
	local selectedDisplay = Instance.new("Frame")
	selectedDisplay.Name = "SelectedDisplay"
	selectedDisplay.Size = UDim2.new(0,40,0,40)
	selectedDisplay.Position = UDim2.new(1, -45, 1, -45)
	selectedDisplay.BackgroundColor3 = defaultColor
	selectedDisplay.BorderSizePixel = 0
	selectedDisplay.Parent = container
	selectedDisplay.ZIndex = 3
	
	-- When the user clicks or drags on the pickerFrame, update the chosen color.
	local function updateColor(input)
		local absPos = pickerFrame.AbsolutePosition
		local absSize = pickerFrame.AbsoluteSize
		local relX = math.clamp((input.Position.X - absPos.X) / absSize.X, 0, 1)
		local relY = math.clamp((input.Position.Y - absPos.Y) / absSize.Y, 0, 1)
		-- Use X as Hue, and Y (inverted) as Saturation; value is fixed at 1.
		local chosenColor = Color3.fromHSV(relX, 1 - relY, 1)
		selectedDisplay.BackgroundColor3 = chosenColor
		if callback then
			callback(chosenColor)
		end
	end
	
	pickerFrame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			updateColor(input)
		end
	end)
	pickerFrame.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement then
			updateColor(input)
		end
	end)
	
	return container
end

-- Example usage:
-- exampleSection:AddColorPicker({
--     Label = "Pick a Color",
--     Default = Color3.fromRGB(0,150,255),
--     Size = UDim2.new(0,200,0,200)
-- }, function(chosenColor)
--     print("Chosen color:", chosenColor)
--     -- Additional functionality goes here.
-- end)

-- Base UI Window & Tab System with Sections
---------------------------
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

if game.CoreGui:FindFirstChild("CometUI") then
	game.CoreGui:FindFirstChild("CometUI"):Destroy()
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CometUI"
screenGui.Parent = game.CoreGui
screenGui.IgnoreGuiInset = true

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- SERVICES
local TweenService = game:GetService("TweenService")
-- (Assume screenGui is already defined.)

---------------------------------------------------------------------
-- MAIN FRAME SETUP
---------------------------------------------------------------------
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Parent = screenGui
mainFrame.Size = UDim2.new(0, 500, 0, 500)
mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
mainFrame.BackgroundTransparency = 0
mainFrame.ClipsDescendants = true

-- Rounded corners
local mainCorner = Instance.new("UICorner", mainFrame)
mainCorner.CornerRadius = UDim.new(0, 16)

-- Stroke for a cool outline effect
local mainStroke = Instance.new("UIStroke", mainFrame)
mainStroke.Thickness = 3
mainStroke.Color = Color3.fromRGB(0, 150, 255)
mainStroke.Transparency = 0.1

---------------------------------------------------------------------
-- DYNAMIC (ANIMATED) GRADIENT
---------------------------------------------------------------------
-- This gradient creates a fluid, liquid-like background.
local dynamicGradient = Instance.new("UIGradient")
dynamicGradient.Name = "DynamicGradient"
dynamicGradient.Rotation = 45
dynamicGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(10, 10, 10)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 50, 100)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(10, 10, 10))
})
dynamicGradient.Offset = Vector2.new(0, 0)
dynamicGradient.Parent = mainFrame

-- Animate the gradient's offset for a liquid flow effect.
coroutine.wrap(function()
    while mainFrame and mainFrame.Parent do
        local tweenOffset1 = TweenService:Create(dynamicGradient, TweenInfo.new(4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Offset = Vector2.new(0.5, 0.2)})
        tweenOffset1:Play()
        tweenOffset1.Completed:Wait()
        local tweenOffset2 = TweenService:Create(dynamicGradient, TweenInfo.new(4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Offset = Vector2.new(0, 0)})
        tweenOffset2:Play()
        tweenOffset2.Completed:Wait()
    end
end)()

-- Animate the gradient's rotation to add extra fluidity.
coroutine.wrap(function()
    while mainFrame and mainFrame.Parent do
        local tweenRot1 = TweenService:Create(dynamicGradient, TweenInfo.new(6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Rotation = 60})
        tweenRot1:Play()
        tweenRot1.Completed:Wait()
        local tweenRot2 = TweenService:Create(dynamicGradient, TweenInfo.new(6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Rotation = 45})
        tweenRot2:Play()
        tweenRot2.Completed:Wait()
    end
end)()

---------------------------------------------------------------------
-- STROKE PULSE ANIMATION
---------------------------------------------------------------------
-- This coroutine animates the stroke's color to give a pulsing effect.
coroutine.wrap(function()
    while mainFrame and mainFrame.Parent do
        local tweenStroke1 = TweenService:Create(mainStroke, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Color = Color3.fromRGB(0, 150, 255)})
        tweenStroke1:Play()
        tweenStroke1.Completed:Wait()
        local tweenStroke2 = TweenService:Create(mainStroke, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Color = Color3.fromRGB(0, 100, 180)})
        tweenStroke2:Play()
        tweenStroke2.Completed:Wait()
    end
end)()

---------------------------------------------------------------------
-- OVERLAY (STATIC) GRADIENT
---------------------------------------------------------------------
-- An additional gradient layer for extra depth. This one remains static.
local overlayGradient = Instance.new("UIGradient")
overlayGradient.Name = "OverlayGradient"
overlayGradient.Rotation = 90
overlayGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(10, 10, 10)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
}
overlayGradient.Parent = mainFrame


local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-----------------------------------------------------------
-- TITLEBAR SETUP
-----------------------------------------------------------
-- SERVICES
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-----------------------------------------------------------
-- TITLEBAR SETUP
-----------------------------------------------------------
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Parent = mainFrame  -- Ensure mainFrame is defined.
titleBar.Size = UDim2.new(1, 0, 0, 50)
titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
titleBar.BorderSizePixel = 0
titleBar.Active = true
titleBar.Selectable = true

-----------------------------------------------------------
-- DRAGGABILITY (Your Existing Code)
-----------------------------------------------------------
local dragging = false
local dragInput, dragStart, startPos
local targetPos = mainFrame.Position

titleBar.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = mainFrame.Position
		targetPos = startPos
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

titleBar.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		dragInput = input
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if input == dragInput and dragging then
		local delta = input.Position - dragStart
		targetPos = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end)

RunService.RenderStepped:Connect(function()
	if dragging then
		mainFrame.Position = mainFrame.Position:Lerp(targetPos, 0.2)
	end
end)

-----------------------------------------------------------
-- TITLEBAR VISUAL EFFECTS
-----------------------------------------------------------
-- Rounded corners on the titleBar.
local titleBarCorner = Instance.new("UICorner", titleBar)
titleBarCorner.CornerRadius = UDim.new(0, 16)

-- Background gradient for the titleBar.
local titleGradient = Instance.new("UIGradient", titleBar)
titleGradient.Rotation = 90
titleGradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(20, 20, 20)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(10, 10, 10))
}

-----------------------------------------------------------
-- ACCENT LINE EFFECT
-----------------------------------------------------------
local accentLine = Instance.new("Frame")
accentLine.Name = "AccentLine"
accentLine.Parent = titleBar
accentLine.Size = UDim2.new(1, 0, 0, 4)
accentLine.Position = UDim2.new(0, 0, 1, -4)
accentLine.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
accentLine.BackgroundTransparency = 0
accentLine.BorderSizePixel = 0

-- Pulsing color animation.
local accentColorTween = TweenService:Create(accentLine, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {BackgroundColor3 = Color3.fromRGB(0, 200, 255)})
accentColorTween:Play()

-- Pulsing transparency animation.
local accentTransparencyTween = TweenService:Create(accentLine, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {BackgroundTransparency = 0.15})
accentTransparencyTween:Play()

-----------------------------------------------------------
-- TITLE TEXT SETUP
-----------------------------------------------------------
local titleText = Instance.new("TextLabel")
titleText.Name = "TitleText"
titleText.Parent = titleBar
titleText.Size = UDim2.new(1, -120, 1, 0)
titleText.Position = UDim2.new(0, 20, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "CometWare"
titleText.Font = Enum.Font.GothamBold
titleText.TextSize = 28
titleText.TextStrokeTransparency = 0.7
titleText.TextXAlignment = Enum.TextXAlignment.Left
titleText.TextColor3 = Color3.fromRGB(240, 240, 240)

-- Drop shadow behind the title text for extra depth.
local titleShadow = Instance.new("TextLabel")
titleShadow.Name = "TitleShadow"
titleShadow.Parent = titleBar
titleShadow.Size = titleText.Size
titleShadow.Position = titleText.Position + UDim2.new(0, 2, 0, 2)
titleShadow.BackgroundTransparency = 1
titleShadow.Text = titleText.Text
titleShadow.Font = titleText.Font
titleShadow.TextSize = titleText.TextSize
titleShadow.TextStrokeTransparency = titleText.TextStrokeTransparency
titleShadow.TextXAlignment = titleText.TextXAlignment
titleShadow.TextColor3 = Color3.new(0, 0, 0)
titleShadow.ZIndex = titleText.ZIndex - 1

-----------------------------------------------------------
-- TITLE TEXT SHINE EFFECT
-----------------------------------------------------------
local textGradient = Instance.new("UIGradient", titleText)
textGradient.Rotation = 0
textGradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 150, 255)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(240, 240, 240))
}
textGradient.Offset = Vector2.new(-0.2, 0)

-- Animate the gradient's offset for a flowing shine effect.
coroutine.wrap(function()
	while true do
		local tween1 = TweenService:Create(textGradient, TweenInfo.new(4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Offset = Vector2.new(1, 0)})
		tween1:Play()
		tween1.Completed:Wait()
		local tween2 = TweenService:Create(textGradient, TweenInfo.new(4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Offset = Vector2.new(-0.2, 0)})
		tween2:Play()
		tween2.Completed:Wait()
	end
end)()

-----------------------------------------------------------
-- ADDITIONAL HOVER & INTERACTION EFFECTS
-----------------------------------------------------------
-- TitleBar hover effect: a subtle lightening.
titleBar.MouseEnter:Connect(function()
	TweenService:Create(titleBar, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = Color3.fromRGB(25, 25, 25)}):Play()
end)
titleBar.MouseLeave:Connect(function()
	TweenService:Create(titleBar, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = Color3.fromRGB(20, 20, 20)}):Play()
end)

-- TitleText hover pulse: slightly brighten the text and reduce stroke transparency.
titleText.MouseEnter:Connect(function()
	TweenService:Create(titleText, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextStrokeTransparency = 0.5, TextColor3 = Color3.fromRGB(255, 255, 255)}):Play()
end)
titleText.MouseLeave:Connect(function()
	TweenService:Create(titleText, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextStrokeTransparency = 0.7, TextColor3 = Color3.fromRGB(240, 240, 240)}):Play()
end)



local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")

local minimizeButton = Instance.new("TextButton")
minimizeButton.Name = "MinimizeButton"
minimizeButton.Parent = titleBar
minimizeButton.Size = UDim2.new(0, 30, 0, 30)
minimizeButton.Position = UDim2.new(1, -85, 0, 10)
minimizeButton.BackgroundColor3 = Color3.fromRGB(150, 150, 150)
minimizeButton.Text = "–"
minimizeButton.Font = Enum.Font.GothamSemibold
minimizeButton.TextSize = 20
minimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)

local minCorner = Instance.new("UICorner", minimizeButton)
minCorner.CornerRadius = UDim.new(0, 8)

local minGradient = Instance.new("UIGradient", minimizeButton)
minGradient.Rotation = 90
minGradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(150, 150, 150)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(130, 130, 130))
}

local minScale = Instance.new("UIScale", minimizeButton)
minScale.Scale = 1

minimizeButton.MouseEnter:Connect(function()
	TweenService:Create(minScale, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1.2}):Play()
	TweenService:Create(minimizeButton, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = Color3.fromRGB(240, 240, 240)}):Play()
	TweenService:Create(minGradient, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(240, 240, 240)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(220, 220, 220))
	}}):Play()
end)

minimizeButton.MouseLeave:Connect(function()
	TweenService:Create(minScale, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1}):Play()
	TweenService:Create(minimizeButton, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = Color3.fromRGB(150, 150, 150)}):Play()
	TweenService:Create(minGradient, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(150, 150, 150)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(130, 130, 130))
	}}):Play()
end)

minimizeButton.MouseButton1Down:Connect(function()
	TweenService:Create(minScale, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 0.9}):Play()
	local ripple = Instance.new("Frame")
	ripple.Name = "Ripple"
	ripple.Parent = minimizeButton
	ripple.Size = UDim2.new(0, 0, 0, 0)
	ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
	ripple.AnchorPoint = Vector2.new(0.5, 0.5)
	ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	ripple.BackgroundTransparency = 0.3
	local rippleCorner = Instance.new("UICorner", ripple)
	rippleCorner.CornerRadius = UDim.new(1, 0)
	TweenService:Create(ripple, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(2, 0, 2, 0), BackgroundTransparency = 1}):Play()
	task.delay(0.3, function() ripple:Destroy() end)
end)

minimizeButton.MouseButton1Up:Connect(function()
	TweenService:Create(minScale, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1.2}):Play()
end)

minimizeButton.MouseButton1Click:Connect(function()
	mainFrame.Visible = false
	StarterGui:SetCore("SendNotification", {
		Title = "UI Minimized",
		Text = "Press K to restore the UI.",
		Duration = 5,
	})
end)



local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")

-- Assume these variables are defined:
-- titleBar  : the parent frame for title bar UI elements.
-- mainFrame : your main UI container frame.
-- screenGui : the top-level ScreenGui containing your UI.

-- Create the Close Button.
local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Parent = titleBar
closeButton.Position = UDim2.new(1, -50, 0, 10)  -- shifted 20 pixels further left from the edge
closeButton.Size = UDim2.new(0, 30, 0, 30)
closeButton.BackgroundColor3 = Color3.fromRGB(220, 60, 60)
closeButton.Text = "X"
closeButton.Font = Enum.Font.GothamSemibold
closeButton.TextSize = 20
closeButton.TextColor3 = Color3.fromRGB(240, 240, 240)

local closeCorner = Instance.new("UICorner", closeButton)
closeCorner.CornerRadius = UDim.new(0, 5)

local closeScale = Instance.new("UIScale", closeButton)
closeScale.Scale = 1

-- MouseEnter/Leave animations.
closeButton.MouseEnter:Connect(function()
	TweenService:Create(closeScale, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1.2}):Play()
	TweenService:Create(closeButton, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = Color3.fromRGB(240, 80, 80)}):Play()
end)

closeButton.MouseLeave:Connect(function()
	TweenService:Create(closeScale, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1}):Play()
	TweenService:Create(closeButton, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = Color3.fromRGB(220, 60, 60)}):Play()
end)

-- Ripple effect on MouseButton1Down.
closeButton.MouseButton1Down:Connect(function()
	local ripple = Instance.new("Frame")
	ripple.Size = UDim2.new(0, 0, 0, 0)
	ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
	ripple.AnchorPoint = Vector2.new(0.5, 0.5)
	ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	ripple.BackgroundTransparency = 0.3
	ripple.Parent = closeButton
	local rippleCorner = Instance.new("UICorner", ripple)
	rippleCorner.CornerRadius = UDim.new(1, 0)
	TweenService:Create(ripple, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = UDim2.new(2, 0, 2, 0), 
		BackgroundTransparency = 1
	}):Play()
	task.delay(0.3, function()
		if ripple and ripple.Parent then
			ripple:Destroy()
		end
	end)
end)

-- Prevent multiple close triggers.
local isClosing = false

closeButton.MouseButton1Click:Connect(function()
	if isClosing then return end
	isClosing = true
	
	-- Set a global flag to indicate that the UI is closed.
	_G.UIClosed = true
	
	-- Fade out animation on mainFrame (keep your beloved animation intact).
	local closeTween = TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundTransparency = 1,
		Size = UDim2.new(0, 0, 0, 0)
	})
	closeTween:Play()
	
	closeTween.Completed:Connect(function()
		-- Optionally, you can perform any additional cleanup here.
		-- Destroy the ScreenGui to fully kill the UI and stop any further code from running.
		if screenGui and screenGui.Parent then
			screenGui:Destroy()
		end
	end)
end)

-- Step 1: Create the Theme Button in the titleBar and define all necessary functions

local TweenService = game:GetService("TweenService")

-- Define the toggleThemePanel function inline.
-- This function toggles the visibility of 'themePanel' (which should be defined in Step 2).
local function toggleThemePanel()
    if themePanel then
        themePanel.Visible = not themePanel.Visible
        print("Theme panel toggled to", themePanel.Visible and "visible" or "hidden")
    else
        warn("toggleThemePanel: themePanel is not defined!")
    end
end

-- Create the theme button
local themeButton = Instance.new("TextButton")
themeButton.Name = "ThemeButton"
themeButton.Parent = titleBar  -- Assumes 'titleBar' is already defined in your UI
themeButton.Size = UDim2.new(0, 30, 0, 30)
-- Position it to the left of the minimize button.
-- For example, if the minimize button is at UDim2.new(1, -85, 0, 10), then this button is placed at UDim2.new(1, -120, 0, 10)
themeButton.Position = UDim2.new(1, -120, 0, 10)
-- Do not change the default AnchorPoint (so it remains (0, 0)) to preserve its placement.
themeButton.BackgroundColor3 = Color3.fromRGB(128, 0, 128)  -- Purple background
themeButton.BorderSizePixel = 0
themeButton.Text = "✨"  -- Using the emoji without asterisks
themeButton.Font = Enum.Font.GothamBold
themeButton.TextSize = 20
themeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
themeButton.AutoButtonColor = false  -- We'll handle hover effects manually

-- Add rounded corners for a polished look.
local themeCorner = Instance.new("UICorner", themeButton)
themeCorner.CornerRadius = UDim.new(0, 8)

-- Add a UIScale for smooth hover scaling.
local themeScale = Instance.new("UIScale", themeButton)
themeScale.Scale = 1

-- Set up hover animations using TweenService.
themeButton.MouseEnter:Connect(function()
    TweenService:Create(themeScale, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1.1}):Play()
    TweenService:Create(themeButton, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        {BackgroundColor3 = Color3.fromRGB(150, 0, 150)}):Play()
end)

themeButton.MouseLeave:Connect(function()
    TweenService:Create(themeScale, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1}):Play()
    TweenService:Create(themeButton, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        {BackgroundColor3 = Color3.fromRGB(128, 0, 128)}):Play()
end)

-- Add clicking animations (ripple effect and scale change) similar to your minimize button.
themeButton.MouseButton1Down:Connect(function()
    TweenService:Create(themeScale, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 0.9}):Play()
    local ripple = Instance.new("Frame")
    ripple.Name = "Ripple"
    ripple.Parent = themeButton
    ripple.Size = UDim2.new(0, 0, 0, 0)
    ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
    ripple.AnchorPoint = Vector2.new(0.5, 0.5)
    ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ripple.BackgroundTransparency = 0.3
    local rippleCorner = Instance.new("UICorner", ripple)
    rippleCorner.CornerRadius = UDim.new(1, 0)
    TweenService:Create(ripple, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        {Size = UDim2.new(2, 0, 2, 0), BackgroundTransparency = 1}):Play()
    task.delay(0.3, function() 
        if ripple then 
            ripple:Destroy() 
        end
    end)
end)

themeButton.MouseButton1Up:Connect(function()
    TweenService:Create(themeScale, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1.1}):Play()
end)

-- When the theme button is clicked, call toggleThemePanel.
themeButton.MouseButton1Click:Connect(function()
    toggleThemePanel()
end)

print("Theme button created in titleBar; toggleThemePanel function defined.")


-----------------------------------------------
-- Step 2: Create the Dropdown Panel for Themes
-----------------------------------------------

-- Ensure 'screenGui' is defined from mainFrame's parent.
local screenGui = mainFrame.Parent
if not screenGui or not screenGui:IsA("ScreenGui") then
    error("mainFrame's parent is not a ScreenGui!")
end

-- Create the theme panel
local themePanel = Instance.new("Frame")
themePanel.Name = "ThemePanel"
themePanel.Parent = screenGui  -- Parent the panel to the ScreenGui for global overlay
-- Adjust the position as desired; here we place it toward the top-right of the screen.
themePanel.Position = UDim2.new(0.75, 0, 0.15, 0)
themePanel.Size = UDim2.new(0, 220, 0, 180)
themePanel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
themePanel.BorderSizePixel = 0
themePanel.Visible = false  -- Start hidden

-- Add UIPadding for internal margins
local panelPadding = Instance.new("UIPadding", themePanel)
panelPadding.PaddingTop = UDim.new(0, 10)
panelPadding.PaddingBottom = UDim.new(0, 10)
panelPadding.PaddingLeft = UDim.new(0, 10)
panelPadding.PaddingRight = UDim.new(0, 10)

-- Add a UIListLayout for vertical alignment of options
local panelLayout = Instance.new("UIListLayout", themePanel)
panelLayout.SortOrder = Enum.SortOrder.LayoutOrder
panelLayout.Padding = UDim.new(0, 8)

-- Create a title label for the panel
local panelTitle = Instance.new("TextLabel")
panelTitle.Name = "PanelTitle"
panelTitle.Parent = themePanel
panelTitle.Size = UDim2.new(1, 0, 0, 25)
panelTitle.BackgroundTransparency = 1
panelTitle.Text = "Select Theme"
panelTitle.TextColor3 = Color3.fromRGB(240, 240, 240)
panelTitle.Font = Enum.Font.GothamBold
panelTitle.TextSize = 20
panelTitle.LayoutOrder = 1

-- Debug print to confirm the panel has been created
print("Theme Panel created. It is currently hidden.")



local tabButtonsFrame = Instance.new("Frame")
tabButtonsFrame.Name = "TabButtonsFrame"
tabButtonsFrame.Parent = mainFrame
tabButtonsFrame.Size = UDim2.new(1, 0, 0, 40)
tabButtonsFrame.Position = UDim2.new(0, 0, 0, 60)
tabButtonsFrame.BackgroundTransparency = 1

local tabContentFrame = Instance.new("Frame")
tabContentFrame.Name = "TabContentFrame"
tabContentFrame.Parent = mainFrame
tabContentFrame.Size = UDim2.new(1, 0, 1, -50)
tabContentFrame.Position = UDim2.new(0, 0, 0, 120)
tabContentFrame.BackgroundTransparency = 1
tabContentFrame.ClipsDescendants = true

local contentLayout = Instance.new("UIListLayout", tabContentFrame)
contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
contentLayout.Padding = UDim.new(0, 0)

-- SERVICES
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")


local windowAPI = {}
windowAPI.TabButtonsFrame = tabButtonsFrame
windowAPI.TabContentFrame = tabContentFrame
windowAPI.Tabs = {}
windowAPI.ActiveTab = nil



-- Tabs
local TweenService = game:GetService("TweenService")
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(duration or 0.3, easingStyle or Enum.EasingStyle.Sine, easingDirection or Enum.EasingDirection.Out, 0, false, delay or 0)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

local function createTab(windowAPI, tabName)
	local tab = {}
	tab.Name = tabName
	tab.Sections = {}
	local tabButtonsFrame = windowAPI.TabButtonsFrame
	
	-- Make sure the tab buttons frame has a UIListLayout.
	if not tabButtonsFrame:FindFirstChildOfClass("UIListLayout") then
		local listLayout = Instance.new("UIListLayout")
		listLayout.FillDirection = Enum.FillDirection.Horizontal
		listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
		listLayout.VerticalAlignment = Enum.VerticalAlignment.Center
		listLayout.Padding = UDim.new(0, 5)
		listLayout.Parent = tabButtonsFrame
	end

	-- Create the tab button using a blue theme.
	local tabButton = Instance.new("TextButton")
	tabButton.Name = "TabButton"
	tabButton.Text = tabName
	tabButton.Size = UDim2.new(0, 120, 1, 0)
	-- Normal state: a nice blue that contrasts well with a black background.
	-- Text is white for clarity.
	tabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	tabButton.Font = Enum.Font.GothamBold
	tabButton.TextSize = 16
	tabButton.AutoButtonColor = false
	tabButton.BorderSizePixel = 0
	tabButton.ZIndex = 1
	tabButton.Parent = tabButtonsFrame

	-- Apply a subtle blue gradient.
	local buttonGradient = Instance.new("UIGradient")
	buttonGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(52, 152, 219)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(42, 132, 199))
	})
	buttonGradient.Rotation = 90
	buttonGradient.Parent = tabButton

	-- Rounded corners.
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = tabButton

local TweenService = game:GetService("TweenService")

local indicator = Instance.new("Frame")
indicator.Name = "ActiveIndicator"
-- Start with zero width so the animation can slide in.
indicator.Size = UDim2.new(0, 0, 0, 3)
indicator.Position = UDim2.new(0, 0, 1, -3)
indicator.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
indicator.BackgroundTransparency = 0
indicator.BorderSizePixel = 0
indicator.ZIndex = 3
indicator.Parent = tabButton

local gradient = Instance.new("UIGradient", indicator)
gradient.Rotation = 90
gradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 150, 255)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 200, 255))
})

-- Animate the indicator to slide in and fill the entire width of the tab button.
TweenService:Create(indicator, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Size = UDim2.new(1, 0, 0, 3)}):Play()


	-- UIScale for smooth scaling effects.
	local scaleObj = Instance.new("UIScale")
	scaleObj.Scale = 1
	scaleObj.Parent = tabButton

	-- Mouse hover: scale up slightly and change to a lighter blue.
	tabButton.MouseEnter:Connect(function()
		if windowAPI.ActiveTab ~= tab then
			tween(scaleObj, {Scale = 1.05}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
			tween(tabButton, {BackgroundColor3 = Color3.fromRGB(74, 168, 230)}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		end
	end)
	tabButton.MouseLeave:Connect(function()
		if windowAPI.ActiveTab ~= tab then
			tween(scaleObj, {Scale = 1}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
			tween(tabButton, {BackgroundColor3 = Color3.fromRGB(52, 152, 219)}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		end
	end)

	-- On click, reset all tabs then activate this one.
	tabButton.MouseButton1Click:Connect(function()
		for _, t in pairs(windowAPI.Tabs) do
			if t.Button then
				tween(t.Button, {BackgroundColor3 = Color3.fromRGB(52, 152, 219)}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
				local ind = t.Button:FindFirstChild("ActiveIndicator")
				if ind then
					tween(ind, {BackgroundTransparency = 1}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
				end
				local s = t.Button:FindFirstChildOfClass("UIScale")
				if s then
					tween(s, {Scale = 1}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
				end
			end
			if t.Content then
				t.Content.Visible = false
			end
		end
		-- Active state: change to a slightly darker blue.
		tween(tabButton, {BackgroundColor3 = Color3.fromRGB(32, 132, 199)}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		if tabButton:FindFirstChild("ActiveIndicator") then
			tween(tabButton.ActiveIndicator, {BackgroundTransparency = 0}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		end
		tab.Content.Visible = true
		windowAPI.ActiveTab = tab
	end)

	-- If this is the first tab, set it as active.
	local initActive = not windowAPI.ActiveTab
	if initActive then
		windowAPI.ActiveTab = tab 
		tween(tabButton, {BackgroundColor3 = Color3.fromRGB(32, 132, 199)}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		if tabButton:FindFirstChild("ActiveIndicator") then
			tween(tabButton.ActiveIndicator, {BackgroundTransparency = 0}, 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		end
	end

	-- Create the tab content container.
	local tabContent = Instance.new("ScrollingFrame")
	tabContent.Name = "TabContent_" .. tabName
	tabContent.Size = UDim2.new(1, -10, 1, -10)
	tabContent.Position = UDim2.new(0, 5, 0, 5)
	tabContent.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	tabContent.BackgroundTransparency = 1
	tabContent.BorderSizePixel = 0
	tabContent.ScrollBarThickness = 4
	tabContent.Visible = initActive
	tabContent.ZIndex = 2
	tabContent.Parent = windowAPI.TabContentFrame

	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 5)
	listLayout.Parent = tabContent

	tab.Button = tabButton
	tab.Content = tabContent

function tab:AddSection(sectionName)
	local section = {}
	section.Name = sectionName
	local sectionFrame = Instance.new("Frame")
	sectionFrame.Name = "Section_" .. sectionName
	sectionFrame.Size = UDim2.new(1, 0, 0, 0)
	sectionFrame.BackgroundTransparency = 1
	sectionFrame.Parent = tabContent

	local sectionLayout = Instance.new("UIListLayout", sectionFrame)
	sectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
	sectionLayout.Padding = UDim.new(0, 10)

	section.Frame = sectionFrame

	function section:AddSlider(opts, callback)
		createSlider(sectionFrame, opts, callback)
	end
	function section:AddToggle(opts, callback)
		createToggle(sectionFrame, opts, callback)
	end
	function section:AddButton(opts, callback)
		createButton(sectionFrame, opts, callback)
	end
	function section:AddColorPicker(opts, callback)
		-- Create the Color Picker UI element and parent it to the sectionFrame.
		createColorPicker(opts, callback).Parent = sectionFrame
	end

	table.insert(tab.Sections, section)
	return section
end

	table.insert(windowAPI.Tabs, tab)
	return tab
end
--------------------------------------------------
-- Add a new tab via your windowAPI.
--------------------------------------------------
function windowAPI:AddTab(tabName)
	return createTab(self, tabName)
end

---------------------------
-- UI Visibility Toggle (RightShift)
---------------------------
-- Upgraded UI Visibility Script with Minimized Check

-- Services
local TweenService    = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local StarterGui      = game:GetService("StarterGui")
-- local Lighting        = game:GetService("Lighting")  -- Uncomment if you want to use a blur effect

--------------------------------------------------
-- Helper Tween Function
--------------------------------------------------
local function tween(object, properties, duration, easingStyle, easingDirection, delay, callback)
	local tweenInfo = TweenInfo.new(
		duration or 0.35,
		easingStyle or Enum.EasingStyle.Sine,
		easingDirection or Enum.EasingDirection.Out,
		0,
		false,
		delay or 0
	)
	local t = TweenService:Create(object, tweenInfo, properties)
	if callback then
		t.Completed:Connect(callback)
	end
	t:Play()
	return t
end

--------------------------------------------------
-- Fade Out and Hide Function
--------------------------------------------------
local function fadeOutAndHide(ui, duration)
	duration = duration or 0.35
	local delayIncrement = 0.02
	local currentDelay = 0
	
	-- Iterate through all GUI descendants for a cascading fade-out effect.
	for _, descendant in ipairs(ui:GetDescendants()) do
		if descendant:IsA("GuiObject") then
			-- Fade out the BackgroundTransparency.
			if descendant.BackgroundTransparency ~= nil then
				if descendant:GetAttribute("origBackgroundTransparency") == nil then
					descendant:SetAttribute("origBackgroundTransparency", descendant.BackgroundTransparency)
				end
				TweenService:Create(descendant, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, currentDelay), 
					{BackgroundTransparency = 1}):Play()
			end
			
			-- Fade out the TextTransparency for text elements.
			if descendant:IsA("TextLabel") or descendant:IsA("TextButton") or descendant:IsA("TextBox") then
				if descendant.TextTransparency ~= nil then
					if descendant:GetAttribute("origTextTransparency") == nil then
						descendant:SetAttribute("origTextTransparency", descendant.TextTransparency)
					end
					TweenService:Create(descendant, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, currentDelay), 
						{TextTransparency = 1}):Play()
				end
			end
			
			-- Fade out the ImageTransparency for image elements.
			if descendant:IsA("ImageLabel") or descendant:IsA("ImageButton") then
				if descendant.ImageTransparency ~= nil then
					if descendant:GetAttribute("origImageTransparency") == nil then
						descendant:SetAttribute("origImageTransparency", descendant.ImageTransparency)
					end
					TweenService:Create(descendant, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, currentDelay), 
						{ImageTransparency = 1}):Play()
				end
			end
			
			-- Fade out any UIStroke objects within the descendant.
			for _, child in ipairs(descendant:GetChildren()) do
				if child:IsA("UIStroke") then
					if child:GetAttribute("origStrokeTransparency") == nil then
						child:SetAttribute("origStrokeTransparency", child.Transparency)
					end
					TweenService:Create(child, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, currentDelay), 
						{Transparency = 1}):Play()
				end
			end
			
			currentDelay = currentDelay + delayIncrement
		end
	end
	
	-- After all tweening completes, hide the UI.
	delay(duration + currentDelay, function()
		ui.Visible = false
	end)
end


--------------------------------------------------
-- Fade In and Show Function
--------------------------------------------------
--[[
    Polished FadeInAndShow Function
    --------------------------------
    This function is designed to fade in a UI element and all of its descendant GuiObjects
    with a smooth, cascading ripple effect. It works by:

      1. Ensuring the top-level UI is visible.
      2. Recursively initializing every descendant’s transparency to 1 (i.e. fully invisible).
      3. Recursively tweening each descendant's transparency properties back to 0 (i.e. fully visible)
         with a slight per-element delay, creating a cascading effect.
      
    Customization Options:
      - duration: Overall tween duration for each element (default is 0.35 seconds).
      - options (table):
          • CascadeDelay: Additional delay (in seconds) per descendant (default is 0.01).
          • EasingStyle: The easing style for the tweens (default is Enum.EasingStyle.Sine).
          • EasingDirection: The easing direction for the tweens (default is Enum.EasingDirection.Out).

    Usage Example:
      local fadeInAndShow = require(path.to.thisModule)  -- if using as a module
      fadeInAndShow(myUI, 0.5, {
          CascadeDelay = 0.015,
          EasingStyle = Enum.EasingStyle.Quad,
          EasingDirection = Enum.EasingDirection.Out,
      })
]]--


local TweenService = game:GetService("TweenService")

local function fadeInAndShow(ui, duration, options)
    duration = duration or 0.35
    options = options or {}
    local cascadeDelay = options.CascadeDelay or 0.01
    local easingStyle = options.EasingStyle or Enum.EasingStyle.Sine
    local easingDirection = options.EasingDirection or Enum.EasingDirection.Out

    -- Make sure the UI is visible.
    ui.Visible = true

    -------------------------------------------------------------
    -- Step 1: Cache original transparencies and initialize them.
    -- For each GuiObject, we store its current transparency (if not already stored)
    -- in an attribute, then set the transparency to 1 (fully invisible) to prepare
    -- for a smooth fade-in.
    -------------------------------------------------------------
    local function cacheAndInitialize(object)
        if object:IsA("GuiObject") then
            -- BackgroundTransparency
            if object.BackgroundTransparency ~= nil then
                if object:GetAttribute("origBackgroundTransparency") == nil then
                    object:SetAttribute("origBackgroundTransparency", object.BackgroundTransparency)
                end
                object.BackgroundTransparency = 1
            end

            -- TextTransparency for text elements.
            if object:IsA("TextLabel") or object:IsA("TextButton") or object:IsA("TextBox") then
                if object:GetAttribute("origTextTransparency") == nil then
                    object:SetAttribute("origTextTransparency", object.TextTransparency)
                end
                object.TextTransparency = 1
            end

            -- ImageTransparency for image elements.
            if object:IsA("ImageLabel") or object:IsA("ImageButton") then
                if object:GetAttribute("origImageTransparency") == nil then
                    object:SetAttribute("origImageTransparency", object.ImageTransparency)
                end
                object.ImageTransparency = 1
            end

            -- For any UIStroke children, do the same.
            for _, child in ipairs(object:GetChildren()) do
                if child:IsA("UIStroke") then
                    if child:GetAttribute("origStrokeTransparency") == nil then
                        child:SetAttribute("origStrokeTransparency", child.Transparency)
                    end
                    child.Transparency = 1
                end
            end
        end

        -- Recursively process all children.
        for _, descendant in ipairs(object:GetChildren()) do
            cacheAndInitialize(descendant)
        end
    end

    cacheAndInitialize(ui)

    -------------------------------------------------------------
    -- Step 2: Tween all transparency properties back to their original values.
    -- A cascading delay is applied so that the fade-in appears as a smooth ripple.
    -------------------------------------------------------------
    local function tweenIn(object, delayOffset)
        delayOffset = delayOffset or 0

        if object:IsA("GuiObject") then
            local tweenInfo = TweenInfo.new(
                duration,
                easingStyle,
                easingDirection,
                0,          -- no repeats
                false,      -- do not reverse
                delayOffset -- cascade delay for this element
            )
            local tweenProps = {}

            if object.BackgroundTransparency ~= nil then
                tweenProps.BackgroundTransparency = object:GetAttribute("origBackgroundTransparency") or 0
            end

            if object:IsA("TextLabel") or object:IsA("TextButton") or object:IsA("TextBox") then
                tweenProps.TextTransparency = object:GetAttribute("origTextTransparency") or 0
            end

            if object:IsA("ImageLabel") or object:IsA("ImageButton") then
                tweenProps.ImageTransparency = object:GetAttribute("origImageTransparency") or 0
            end

            if next(tweenProps) then
                local tween = TweenService:Create(object, tweenInfo, tweenProps)
                tween:Play()
            end

            -- Tween any UIStroke children.
            for _, child in ipairs(object:GetChildren()) do
                if child:IsA("UIStroke") then
                    local strokeTween = TweenService:Create(child, tweenInfo, {
                        Transparency = child:GetAttribute("origStrokeTransparency") or 0
                    })
                    strokeTween:Play()
                end
            end
        end

        -- Recursively process all children with an increased delay.
        for _, child in ipairs(object:GetChildren()) do
            tweenIn(child, delayOffset + cascadeDelay)
        end
    end

    tweenIn(ui, 0)
end


--------------------------------------------------
-- blur effect
--------------------------------------------------

local BlurEffect = Instance.new("BlurEffect")
BlurEffect.Size = 0
BlurEffect.Parent = game.Lighting

local function setBlur(targetSize, duration)
	duration = duration or 0.35
	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local blurTween = TweenService:Create(BlurEffect, tweenInfo, { Size = targetSize })
	blurTween:Play()
end


--------------------------------------------------
-- UI Toggle Keybind Logic with Minimized Check
--------------------------------------------------
local uiVisible = true
local debounce = false

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed or input.UserInputType ~= Enum.UserInputType.Keyboard then
		return
	end
	
	-- Only trigger on the "K" key and if not debounced.
	if input.KeyCode == Enum.KeyCode.K and input.UserInputState == Enum.UserInputState.Begin and not debounce then
		debounce = true
		
		-- Check for the CometUI instance.
		local cometUI = game.CoreGui:FindFirstChild("CometUI")
		if not cometUI then
			debounce = false
			return
		end
		
		-- Remove duplicate UI instances if any.
		for _, child in ipairs(game.CoreGui:GetChildren()) do
			if child.Name == "CometUI" and child ~= cometUI then
				child:Destroy()
			end
		end
		
		-- Get the main frame.
		local mainFrame = cometUI:FindFirstChild("MainFrame")
		if not mainFrame then
			debounce = false
			return
		end
		
		-- Ensure the main frame has a "Minimized" attribute.
		local minimized = mainFrame:GetAttribute("Minimized")
		if minimized == nil then
			minimized = false
			mainFrame:SetAttribute("Minimized", false)
		end
		
		-- Toggle the UI:
		-- If the UI is not visible or is marked as minimized, restore it.
		if (not mainFrame.Visible) or minimized then
			mainFrame:SetAttribute("Minimized", false)
			uiVisible = true
			fadeInAndShow(mainFrame, 0.35)
		else
			-- Otherwise, minimize (hide) the UI.
			uiVisible = false
			mainFrame:SetAttribute("Minimized", true)
			fadeOutAndHide(mainFrame, 0.35)
			StarterGui:SetCore("SendNotification", {
				Title = "UI Hidden",
				Text = "Press K to restore the UI.",
				Duration = 5,
			})
		end
		
		wait(0.35)
		debounce = false
	end
end)


---------------------------
-- Expose the Base Window API Globally via a CometUI module
---------------------------
local CometUI = {}
function CometUI:CreateWindow(config)
    if config then
        if config.Title then
            titleText.Text = config.Title
        end
        if config.Size then
            mainFrame.Size = config.Size
            mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
        end
    end
    return windowAPI
end

_G.baseWindow = CometUI:CreateWindow({ Title = "CometWare", Size = UDim2.new(0,500,0,400) })
print("Base UI created. Use _G.baseWindow:AddTab('Tab Name') to add a new tab.")


local VisualsTab = _G.baseWindow:AddTab("Visuals")
local MovementTab = _G.baseWindow:AddTab("Movement")
local fpsSection = VisualsTab:AddSection("FPS")
local MovementSection = MovementTab:AddSection("Movement")

-- FPS Booster and Revert Functions

FPSBooster = {}

local FPSBooster = {}

function FPSBooster:Boost()
	local Lighting = game:GetService("Lighting")
	
	self.OriginalLighting = {
		GlobalShadows = Lighting.GlobalShadows,
		FogEnd = Lighting.FogEnd,
		Brightness = Lighting.Brightness,
		EnvironmentSpecularScale = Lighting.EnvironmentSpecularScale,
		EnvironmentDiffuseScale = Lighting.EnvironmentDiffuseScale,
	}
	
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") then
			if not obj:GetAttribute("OrigMaterial") then
				obj:SetAttribute("OrigMaterial", obj.Material.Name)
				obj:SetAttribute("OrigReflectance", obj.Reflectance)
			end
			obj.Material = Enum.Material.SmoothPlastic
			obj.Reflectance = 0
		elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") then
			if obj:GetAttribute("OrigEnabled") == nil then
				obj:SetAttribute("OrigEnabled", obj.Enabled)
			end
			obj.Enabled = false
		elseif obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then
			if obj:GetAttribute("OrigEnabled") == nil then
				obj:SetAttribute("OrigEnabled", obj.Enabled)
			end
			obj.Enabled = false
		end
	end
	
	Lighting.GlobalShadows = false
	Lighting.FogEnd = 9e9
	Lighting.Brightness = 1
	Lighting.EnvironmentSpecularScale = 0
	Lighting.EnvironmentDiffuseScale = 0
	
	if workspace:FindFirstChildOfClass("Terrain") then
		workspace.Terrain.Decoration = false
	end
end

function FPSBooster:Revert()
	local Lighting = game:GetService("Lighting")
	
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") then
			local origMat = obj:GetAttribute("OrigMaterial")
			local origRef = obj:GetAttribute("OrigReflectance")
			if origMat then
				-- Use the original material name to revert, or fallback to Plastic.
				obj.Material = Enum.Material[origMat] or Enum.Material.Plastic
			else
				obj.Material = Enum.Material.Plastic
			end
			if origRef ~= nil then
				obj.Reflectance = origRef
			else
				obj.Reflectance = 0.5 -- Fallback value if not stored
			end
		elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") then
			local origEnabled = obj:GetAttribute("OrigEnabled")
			obj.Enabled = (origEnabled ~= nil) and origEnabled or true
		elseif obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then
			local origEnabled = obj:GetAttribute("OrigEnabled")
			obj.Enabled = (origEnabled ~= nil) and origEnabled or true
		end
	end
	
	-- Restore Lighting settings
	if self.OriginalLighting then
		Lighting.GlobalShadows = self.OriginalLighting.GlobalShadows
		Lighting.FogEnd = self.OriginalLighting.FogEnd
		Lighting.Brightness = self.OriginalLighting.Brightness
		Lighting.EnvironmentSpecularScale = self.OriginalLighting.EnvironmentSpecularScale
		Lighting.EnvironmentDiffuseScale = self.OriginalLighting.EnvironmentDiffuseScale
	else
		Lighting.GlobalShadows = true
		Lighting.FogEnd = 100000
		Lighting.Brightness = 2
		Lighting.EnvironmentSpecularScale = 1
		Lighting.EnvironmentDiffuseScale = 1
	end
	
	if workspace:FindFirstChildOfClass("Terrain") then
		workspace.Terrain.Decoration = true
	end
end

-- FPS Booster Toggle in the FPS Section
fpsSection:AddToggle({ 
    Label = "FPS booster", 
    Default = false,
    Size = UDim2.new(0, 300, 0, 40)
}, function(state)
    print("toggle:", state)
    if state then
         FPSBooster:Boost()
    else
         FPSBooster:Revert()
    end
end)

-- Variables
local toggles = {
    customSpeedEnabled = false
}
local customSpeed = 16 -- Default speed

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

toggles = toggles or {}
toggles.customSpeedEnabled = false
customSpeed = 16
local speedConnection

local function applyCustomSpeed()
    if speedConnection then
        speedConnection:Disconnect()
    end
    speedConnection = RunService.Stepped:Connect(function(_, deltaTime)
        if toggles.customSpeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            local rootPart = LocalPlayer.Character.HumanoidRootPart
            if humanoid and humanoid.MoveDirection.Magnitude > 0 then
                local moveDirection = humanoid.MoveDirection * (customSpeed * deltaTime)
                rootPart.CFrame = rootPart.CFrame + Vector3.new(moveDirection.X, 0, moveDirection.Z)
            end
        end
    end)
end

MovementSection:AddToggle({ 
    Label = "Speed", 
    Default = false,
    Size = UDim2.new(0, 300, 0, 40)
}, function(state)
    toggles.customSpeedEnabled = state
    if state then
        applyCustomSpeed()
    else
        if speedConnection then
            speedConnection:Disconnect()
        end
    end
end)

MovementSection:AddSlider({ 
    Label = "Set Speed",
    Min = 16,
    Max = 50,
    Default = 16,
    Size = UDim2.new(0, 300, 0, 100)
}, function(value)
    customSpeed = value
end)

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

toggles = toggles or {}
toggles.customJumpEnabled = false
jumpPower = 50

local function applyCustomJump()
    UserInputService.JumpRequest:Connect(function()
        if toggles.customJumpEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = LocalPlayer.Character.HumanoidRootPart
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if not humanoid or humanoid.FloorMaterial == Enum.Material.Air then return end
            for i = 1, jumpPower, 5 do
                task.wait(0.01)
                rootPart.CFrame = rootPart.CFrame + Vector3.new(0, 0.5, 0)
            end
            task.wait(0.1)
            rootPart.CFrame = rootPart.CFrame + Vector3.new(0, -0.5, 0)
        end
    end)
end

MovementSection:AddToggle({
    Label = "Jump Power",
    Default = false,
    Size = UDim2.new(0, 300, 0, 40)
}, function(Value)
    toggles.customJumpEnabled = Value
    if Value then
        applyCustomJump()
    end
end)

MovementSection:AddSlider({
    Label = "Set Jump Power",
    Range = {10, 100},
    Increment = 5,
    Default = 50,
    Size = UDim2.new(0, 300, 0, 100)
}, function(Value)
    jumpPower = Value
end)

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- State variables
local flying = false
local flySpeed = 5  -- Default fly speed
local flyDirection = Vector3.new(0, 0, 0)
local hrp = nil  -- HumanoidRootPart
local flyConnection = nil

-- Key states for smooth flight movement
local keys = {
    W = false,
    S = false,
    A = false,
    D = false,
    Space = false,
    Shift = false
}

-- Start Fly function (with smooth, interpolated flight)
local function startFly()
    if flying or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    flying = true
    hrp = LocalPlayer.Character.HumanoidRootPart
    hrp.Anchored = true
    flyConnection = RunService.RenderStepped:Connect(function(dt)
        if flying and hrp then
            flyDirection = Vector3.new(
                ((keys.D and 1) or 0) + ((keys.A and -1) or 0),
                ((keys.Space and 1) or 0) + ((keys.Shift and -1) or 0),
                ((keys.S and 1) or 0) + ((keys.W and -1) or 0)
            )
            hrp.CFrame = hrp.CFrame * CFrame.new(flyDirection * flySpeed * 0.1)
        end
    end)
end

-- Stop Fly function
local function stopFly()
    flying = false
    if flyConnection then
        flyConnection:Disconnect()
        flyConnection = nil
    end
    if hrp then
        hrp.Anchored = false
    end
end

-- Update key states for flight
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.W then keys.W = true end
    if input.KeyCode == Enum.KeyCode.S then keys.S = true end
    if input.KeyCode == Enum.KeyCode.A then keys.A = true end
    if input.KeyCode == Enum.KeyCode.D then keys.D = true end
    if input.KeyCode == Enum.KeyCode.Space then keys.Space = true end
    if input.KeyCode == Enum.KeyCode.LeftShift then keys.Shift = true end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.W then keys.W = false end
    if input.KeyCode == Enum.KeyCode.S then keys.S = false end
    if input.KeyCode == Enum.KeyCode.A then keys.A = false end
    if input.KeyCode == Enum.KeyCode.D then keys.D = false end
    if input.KeyCode == Enum.KeyCode.Space then keys.Space = false end
    if input.KeyCode == Enum.KeyCode.LeftShift then keys.Shift = false end
end)

-- UI Integration using your custom UI functions.
-- (Ensure MovementSection is a valid reference to your movement UI section.)
MovementSection:AddToggle({
    Label = "Enable Fly",
    Default = false,
    Size = UDim2.new(0, 300, 0, 40)
}, function(Value)
    if Value then
        startFly()
    else
        stopFly()
    end
end)

MovementSection:AddSlider({
    Label = "Fly Speed",
    Range = {1, 20},
    Increment = 1,
    Default = flySpeed,
    Size = UDim2.new(0, 300, 0, 100)
}, function(Value)
    flySpeed = Value
end)

 MovementSection:AddColorPicker({
    Label = "Pick a Color",
    Default = Color3.fromRGB(0,150,255),
    Size = UDim2.new(0,200,0,200)
}, function(chosenColor)
print("Chosen color:", chosenColor)
     -- Additional functionality goes here.
 end)
